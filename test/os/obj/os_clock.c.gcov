        -:    0:Source:/home/gerald/van_development/van/os/os_clock.c
        -:    1:// SPDX-License-Identifier: GPL-2.0
        -:    2:
        -:    3:/*
        -:    4: * Operating system interfaces.
        -:    5: *
        -:    6: * Copyright (C) 2022 Gerald Schueller <gerald.schueller@web.de>
        -:    7: */
        -:    8:
        -:    9:/*============================================================================
        -:   10:  IMPORTED INCLUDE REFERENCES
        -:   11:  ============================================================================*/
        -:   12:#include <pthread.h>     /* POSIX thread. */
        -:   13:#include <signal.h>      /* for struct sigevent and SIGEV_THREAD */
        -:   14:#include <sys/time.h>    /* Get / set time: gettimeofday(). */
        -:   15:#include <errno.h>       /* Linux error codes: EINTR. */
        -:   16:#include "os.h"          /* Operating system: os_timer_init() */
        -:   17:#include "os_private.h"  /* Local interfaces of the OS: os_tm_init() */
        -:   18:
        -:   19:/*============================================================================
        -:   20:  EXPORTED INCLUDE REFERENCES
        -:   21:  ============================================================================*/
        -:   22:/*============================================================================
        -:   23:  LOCAL NAME CONSTANTS DEFINITIONS
        -:   24:  ============================================================================*/
        -:   25:/* Muliplier for conversion from nanoseconds to millisecondss. */
        -:   26:#define CLOCK_NSEC_M  1000000
        -:   27:
        -:   28:/*============================================================================
        -:   29:  MACROS
        -:   30:  ============================================================================*/
        -:   31:/*============================================================================
        -:   32:  LOCAL TYPE DEFINITIONS
        -:   33:  ============================================================================*/
        -:   34:/**
        -:   35: * tm_t - state of a periodic timer.
        -:   36: *
        -:   37: * @mutex:       protect the critical section in the timer operations.
        -:   38: * @id:          timer id.
        -:   39: * @name:        timer name.
        -:   40: * @assigned:    if 1, the element has been reserved.
        -:   41: * @interval:    repeating interval in milliseconds.
        -:   42: * @suspend:     suspend the wait caller.
        -:   43: * @suspended:   if 1, the caller has been suspend in os_timer_barrier().
        -:   44: * @overrun:     if 1, the caller has not reached os_timer_barrier().
        -:   45: *
        -:   46: * @s_start:     system start time.
        -:   47: * @s_end:       system end time.
        -:   48: * @c_start:     current start time of the transition.
        -:   49: * @busy:        execution time of the last cycle.
        -:   50: * @min:         minimum of the processing time.
        -:   51: * @max:         maximum of the processing time.
        -:   52: * @cycles:      timer expiration counter.
        -:   53: * @k_ov_count:  Linux kernel overrun counter.
        -:   54: * @u_ov_count:  User overrun counter.
        -:   55: **/
        -:   56:typedef struct {
        -:   57:	pthread_mutex_t  mutex;
        -:   58:	
        -:   59:	struct tm_elem_s {
        -:   60:		int         id;
        -:   61:		char        name[OS_MAX_NAME_LEN + 1];
        -:   62:		int         assigned;
        -:   63:		int         interval;
        -:   64:		timer_t     timer_id;
        -:   65:		sem_t       suspend;
        -:   66:		atomic_int  suspended;
        -:   67:		atomic_int  overrun;
        -:   68:		
        -:   69:		struct timeval  s_start;
        -:   70:		struct timeval  s_end;
        -:   71:		struct timeval  c_start;
        -:   72:		struct timeval  busy;
        -:   73:		struct timeval  min;
        -:   74:		struct timeval  max;
        -:   75:		int             cycles;
        -:   76:		int             k_ov_count;
        -:   77:		int             u_ov_count;
        -:   78:	} elem[OS_CLOCK_LIMIT];
        -:   79:} tm_t;
        -:   80:
        -:   81:/*============================================================================
        -:   82:  LOCAL DATA
        -:   83:  ============================================================================*/
        -:   84:/* State of the periodic timer list. */
        -:   85:static tm_t tm;
        -:   86:
        -:   87:/*============================================================================
        -:   88:  LOCAL FUNCTION PROTOTYPES
        -:   89:  ============================================================================*/
        -:   90:/*============================================================================
        -:   91:  LOCAL FUNCTIONS
        -:   92:  ============================================================================*/
        -:   93:/**
        -:   94: * tm_handler() -   this function will be invoked upon timer expiration as if it
        -:   95: * were the start function of a new thread. 
        -:   96: *
        -:   97: * sv:  pointer to the affected timer.
        -:   98: *
        -:   99: * Return:	None.
        -:  100: **/
function tm_handler called 0 returned 0% blocks executed 0%
    #####:  101:static void tm_handler(union sigval sv)
        -:  102:{
        -:  103:	struct tm_elem_s *t;
        -:  104:	int suspended;
        -:  105:	
        -:  106:	/* Get the pointer to the timer descripton. */
    #####:  107:	t = sv.sival_ptr;
        -:  108:
        -:  109:	/* Entry condition. */
    #####:  110:	OS_TRAP_IF(t == NULL || ! t->assigned);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  111:
        -:  112:	/* Test the state of the timer owner. */
    #####:  113:	suspended = atomic_exchange(&t->suspended, 0);
    #####:  114:	if (suspended) {
branch  0 never executed
branch  1 never executed
        -:  115:		/* Resume the suspended caller. */
    #####:  116:		os_sem_release(&t->suspend);
call    0 never executed
    #####:  117:		return;
        -:  118:	}
        -:  119:
        -:  120:	/* Inform the caller because of barrier violation. */
    #####:  121:	atomic_store(&t->overrun, 1);
        -:  122:}
        -:  123:
        -:  124:/**
        -:  125: * tm_create() - install a periodic timer.
        -:  126: *
        -:  127: * @t:  pointer to the timer descripton.
        -:  128: *
        -:  129: * Return:	None.
        -:  130: **/
function tm_create called 0 returned 0% blocks executed 0%
    #####:  131:static void tm_create(struct tm_elem_s *t)
        -:  132:{
        -:  133:	struct sigevent sev;
        -:  134:	int rv;
        -:  135:
        -:  136:	/* Set the notification method as SIGEV_THREAD: upon timer expiration,
        -:  137:	 * tm_handler(), will be invoked as if it were the start function of a
        -:  138:	 * new thread. */
    #####:  139:	os_memset(&sev, 0, sizeof(struct sigevent));
call    0 never executed
    #####:  140:	sev.sigev_notify = SIGEV_THREAD;
    #####:  141:	sev.sigev_notify_function = tm_handler;
    #####:  142:	sev.sigev_value.sival_ptr = t;
        -:  143:
        -:  144:	/* Create a new timer. */
    #####:  145:	rv = timer_create(CLOCK_REALTIME, &sev, &t->timer_id);
call    0 never executed
    #####:  146:	OS_TRAP_IF(rv != 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  147:}
        -:  148:
        -:  149:/**
        -:  150: * tm_ms() - calculate millliseconds.
        -:  151: *
        -:  152: * @tv:  pointer to the time description.
        -:  153: * 
        -:  154: * Return:	milliseconds.
        -:  155: **/
function tm_ms called 0 returned 0% blocks executed 0%
    #####:  156:static long long tm_ms(struct timeval *t)
        -:  157:{
        -:  158:	long long ms;
        -:  159:
        -:  160:	/* Calculate milliseconds */
    #####:  161:	ms = t->tv_sec * 1000LL + t->tv_usec / 1000;
        -:  162:
    #####:  163:	return ms;
        -:  164:}
        -:  165:
        -:  166:/*============================================================================
        -:  167:  EXPORTED FUNCTIONS
        -:  168:  ============================================================================*/
        -:  169:/**
        -:  170: * os_clock_trace() - print timer information.
        -:  171: *
        -:  172: * @id:    assigned timer id by os_clock_init().
        -:  173: * @mode:  configuration of the trace output.
        -:  174: * 
        -:  175: * Return:	None.
        -:  176: **/
function os_clock_trace called 0 returned 0% blocks executed 0%
    #####:  177:void os_clock_trace(int id, int mode)
        -:  178:{
        -:  179:	struct tm_elem_s *t;
        -:  180:	struct timeval res;
        -:  181:	struct tm *l;
        -:  182:	char *n;
        -:  183:	
        -:  184:	/* Enter the critical section. */
    #####:  185:	os_cs_enter(&tm.mutex);
call    0 never executed
        -:  186:	
        -:  187:	/* Entry condition. */
    #####:  188:	OS_TRAP_IF(id < 0 || id >= OS_CLOCK_LIMIT);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  189:
        -:  190:	/* Get the pointer to the timer description. */
    #####:  191:	t = &tm.elem[id];
    #####:  192:	OS_TRAP_IF(! t->assigned);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  193:
        -:  194:	/* Get the pointer to the timer name. */
    #####:  195:	n = t->name;
        -:  196:
        -:  197:	/* Print the system start and end time. */
        -:  198:
        -:  199:	/* System start time. */
    #####:  200:	if(mode == OS_CT_FIRST || mode == OS_CT_LAST) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  201:		l = localtime(&t->s_start.tv_sec);
call    0 never executed
    #####:  202:		printf("%s: proc-start: %d:%0d:%0d.%ld\n", n, 
call    0 never executed
        -:  203:		       l->tm_hour, l->tm_min, l->tm_sec, t->s_start.tv_usec);
        -:  204:	}
        -:  205:	
        -:  206:	/* System end time. */
    #####:  207:	if(mode == OS_CT_LAST) {
branch  0 never executed
branch  1 never executed
    #####:  208:		l = localtime(&t->s_end.tv_sec);
call    0 never executed
    #####:  209:		printf("%s: proc-end:   %d:%0d:%0d.%ld\n", n, 
call    0 never executed
        -:  210:		       l->tm_hour, l->tm_min, l->tm_sec, t->s_end.tv_usec);
        -:  211:		
        -:  212:		/* Calculate the runtime of the cycles. */
    #####:  213:		timersub (&t->s_end, &t->s_start, &res);
branch  0 never executed
branch  1 never executed
    #####:  214:		printf("%s: runtime:    %lld ms\n", n, tm_ms(&res));
call    0 never executed
call    1 never executed
        -:  215:	}
        -:  216:	
        -:  217:	/* Print timer information. */
    #####:  218:	printf("%s: cycles:     %d\n",      n, t->cycles);
call    0 never executed
    #####:  219:	printf("%s: interval:   %d ms\n",   n, t->interval);
call    0 never executed
    #####:  220:	printf("%s: busy:       %lld ms\n", n, tm_ms(&t->busy));
call    0 never executed
call    1 never executed
    #####:  221:	printf("%s: min:        %lld ms\n", n, tm_ms(&t->min));
call    0 never executed
call    1 never executed
    #####:  222:	printf("%s: max:        %lld ms\n", n, tm_ms(&t->max));
call    0 never executed
call    1 never executed
    #####:  223:	printf("%s: kernel-ov:  %d\n",      n, t->k_ov_count);
call    0 never executed
    #####:  224:	printf("%s: user-ov:    %d\n\n",    n, t->u_ov_count);
call    0 never executed
        -:  225:	
        -:  226:	/* Leave the critical section. */
    #####:  227:	os_cs_leave(&tm.mutex);
call    0 never executed
    #####:  228:}
        -:  229:
        -:  230:/**
        -:  231: * os_clock_msleep() - sleep for the requested number of milliseconds.
        -:  232: *
        -:  233: * @msec:  millisecond value.
        -:  234: *
        -:  235: * Return:	None.
        -:  236: **/
function os_clock_msleep called 0 returned 0% blocks executed 0%
    #####:  237:void os_clock_msleep(long msec)
        -:  238:{
        -:  239:	struct timespec ts;
        -:  240:	int rv;
        -:  241:
        -:  242:	/* Entry condition. */
    #####:  243:	OS_TRAP_IF(msec < 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  244:
        -:  245:	/* Map the millisecond value. */
    #####:  246:	ts.tv_sec = msec / 1000;
    #####:  247:	ts.tv_nsec = (msec % 1000) * CLOCK_NSEC_M;
        -:  248:
        -:  249:	do {
        -:  250:		/* Execute the high-resoluton sleep. */
    #####:  251:		rv = nanosleep(&ts, &ts);
call    0 never executed
    #####:  252:	} while (rv && errno == EINTR);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  253:}
        -:  254:
        -:  255:/**
        -:  256: * os_clock_barrier() - ordering timer constraint on controller operations 
        -:  257: * before and after the barrier instructions as agreed in os_clock_init().
        -:  258: *
        -:  259: * @id:  assigned timer id by os_clock_init().
        -:  260: *
        -:  261: * Return:	-1, if the interval has not been met, otherwise 0.
        -:  262: **/
function os_clock_barrier called 0 returned 0% blocks executed 0%
    #####:  263:int os_clock_barrier(int id)
        -:  264:{
        -:  265:        struct itimerspec in;
        -:  266:	struct tm_elem_s *t;
        -:  267:	struct timeval now, res;
        -:  268:	int rv, overrun;
        -:  269:
        -:  270:	/* Enter the critical section. */
    #####:  271:	os_cs_enter(&tm.mutex);
call    0 never executed
        -:  272:	
        -:  273:	/* Entry condition. */
    #####:  274:	OS_TRAP_IF(id < 0 || id >= OS_CLOCK_LIMIT);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  275:
        -:  276:	/* Extended entry condition. */
    #####:  277:	t = &tm.elem[id];
    #####:  278:	OS_TRAP_IF(! t->assigned);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  279:
        -:  280:	/* Update the calculation counter. */
    #####:  281:	t->cycles++;
        -:  282:	
        -:  283:	/* Get the system overrun count for a POSIX per-process timer. */
    #####:  284:	rv = timer_getoverrun(t->timer_id);
call    0 never executed
    #####:  285:	OS_TRAP_IF(rv == -1);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  286:
        -:  287:	/* Save the overrun count caused by system load. */
    #####:  288:	t->k_ov_count = rv;
        -:  289:	
        -:  290:	/* Get the current time. */
    #####:  291:	rv = gettimeofday(&now, NULL);
call    0 never executed
    #####:  292:	OS_TRAP_IF(rv != 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  293:
        -:  294:	/* Calculate the runtime of the transition. */
    #####:  295:	timersub (&now, &t->c_start, &res);
branch  0 never executed
branch  1 never executed
    #####:  296:	t->busy = res;
        -:  297:
        -:  298:	/* Calculate the minimum of the processing time. */
    #####:  299:	if (timercmp(&t->min, &res, >))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  300:		t->min = res;
        -:  301:
        -:  302:	/* Calculate the maximum of the processing time. */
    #####:  303:	if (timercmp(&t->max, &res, <))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  304:		t->max = res;
        -:  305:	
        -:  306:	/* Test the overrun condition. */
    #####:  307:	overrun = atomic_exchange(&t->overrun, 0);
    #####:  308:	if (overrun) {
branch  0 never executed
branch  1 never executed
        -:  309:		/* Update the overrun counter. */
    #####:  310:		t->u_ov_count++;
        -:  311:
        -:  312:		/* Restart the clock timer because of overrun. */
        -:  313:		
        -:  314:		/* Stop the timer. */
    #####:  315:		os_memset(&in, 0, sizeof(struct itimerspec));
call    0 never executed
    #####:  316:		rv = timer_settime(t->timer_id, 0, &in, NULL);
call    0 never executed
    #####:  317:		OS_TRAP_IF(rv != 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  318:
        -:  319:		/* Start the timer again. */
    #####:  320:		os_memset(&in, 0, sizeof(struct itimerspec));
call    0 never executed
    #####:  321:		in.it_value.tv_nsec    = CLOCK_NSEC_M * t->interval;
    #####:  322:		in.it_interval.tv_nsec = CLOCK_NSEC_M * t->interval;
    #####:  323:		rv = timer_settime(t->timer_id, 0, &in, NULL);
call    0 never executed
    #####:  324:		OS_TRAP_IF(rv != 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  325:	}
        -:  326:	else {
        -:  327:		/* Indicate the entering of the barrier. */
    #####:  328:		atomic_store(&t->suspended, 1);
        -:  329:	
        -:  330:		/* Suspend the timer owner. */
    #####:  331:		os_sem_wait (&t->suspend);
call    0 never executed
        -:  332:	}
        -:  333:
        -:  334:	/* Update the current start time of the transition. */
    #####:  335:	rv = gettimeofday(&t->c_start, NULL);
call    0 never executed
        -:  336:
        -:  337:	/* Leave the critical section. */
    #####:  338:	os_cs_leave(&tm.mutex);
call    0 never executed
        -:  339:
        -:  340:	/* Calculate the return value. */
    #####:  341:	if (overrun)
branch  0 never executed
branch  1 never executed
    #####:  342:		return -1;
        -:  343:
    #####:  344:	return 0;
        -:  345:}
        -:  346:
        -:  347:/**
        -:  348: * os_clock_stop() - stop a periodic timer.
        -:  349: *
        -:  350: * @id:  assigned timer id by os_clock_init().
        -:  351: *
        -:  352: * Return:	None.
        -:  353: **/
function os_clock_stop called 0 returned 0% blocks executed 0%
    #####:  354:void os_clock_stop(int id)
        -:  355:{
        -:  356:        struct itimerspec in;
        -:  357:	struct tm_elem_s *t;
        -:  358:	int rv;
        -:  359:	
        -:  360:	/* Enter the critical section. */
    #####:  361:	os_cs_enter(&tm.mutex);
call    0 never executed
        -:  362:	
        -:  363:	/* Entry condition. */
    #####:  364:	OS_TRAP_IF(id < 0 || id >= OS_CLOCK_LIMIT);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  365:
        -:  366:	/* Get the pointer to the timer description. */
    #####:  367:	t = &tm.elem[id];
    #####:  368:	OS_TRAP_IF(! t->assigned);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  369:
        -:  370:	/* Remember the system end time. */
    #####:  371:	rv = gettimeofday(&t->s_end, NULL);
call    0 never executed
    #####:  372:	OS_TRAP_IF(rv != 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  373:
        -:  374:	/* Initialize the timer trigger. */
    #####:  375:	os_memset(&in, 0, sizeof(struct itimerspec));
call    0 never executed
        -:  376:
        -:  377:	/* If the timer was already armed, then the previous settings are
        -:  378:	 * overwritten. If the new values specifies a zero value (i.e., both
        -:  379:	 * subfields are zero, then the timer is disarmed. */
        -:  380:
        -:  381:        /* Disarm the timer. No flags are set and no old values will be
        -:  382:	 * retrieved. */
    #####:  383:        rv = timer_settime(t->timer_id, 0, &in, NULL);
call    0 never executed
    #####:  384:	OS_TRAP_IF(rv != 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  385:
        -:  386:	/* Leave the critical section. */
    #####:  387:	os_cs_leave(&tm.mutex);
call    0 never executed
    #####:  388:}
        -:  389:
        -:  390:/**
        -:  391: * os_clock_start() - start a periodic timer.
        -:  392: *
        -:  393: * @id:  assigned timer id by os_clock_init().
        -:  394: *
        -:  395: * Return:	None.
        -:  396: **/
function os_clock_start called 0 returned 0% blocks executed 0%
    #####:  397:void os_clock_start(int id)
        -:  398:{
        -:  399:        struct itimerspec in;
        -:  400:	struct tm_elem_s *t;
        -:  401:	int rv;
        -:  402:	
        -:  403:	/* Enter the critical section. */
    #####:  404:	os_cs_enter(&tm.mutex);
call    0 never executed
        -:  405:	
        -:  406:	/* Entry condition. */
    #####:  407:	OS_TRAP_IF(id < 0 || id >= OS_CLOCK_LIMIT);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  408:
        -:  409:	/* Get the pointer to the timer description. */
    #####:  410:	t = &tm.elem[id];
    #####:  411:	OS_TRAP_IF(! t->assigned);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  412:
        -:  413:	/* Initialize the timer trigger. */
    #####:  414:	os_memset(&in, 0, sizeof(struct itimerspec));
call    0 never executed
        -:  415:	
        -:  416:        /* Timer expiration will occur withing n millisecons after being armed
        -:  417:         * by timer_settime(). */
    #####:  418:        in.it_value.tv_nsec = CLOCK_NSEC_M * t->interval;
        -:  419:	
        -:  420:	/* Defines the input values for timer_settime(). The key input values is
        -:  421:	 * the interval with the base value 1 ms: CLOCK_NSEC_M0. 
        -:  422:	 * The substructures it_interval of the itimerspec structure allows a
        -:  423:	 * time value to be specified in seconds and nanoseconds. */
    #####:  424:	in.it_interval.tv_nsec = CLOCK_NSEC_M * t->interval;
        -:  425:
        -:  426:	/* Initialize the timer start. */
    #####:  427:	rv = gettimeofday(&t->c_start, NULL);
call    0 never executed
    #####:  428:	OS_TRAP_IF(rv != 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  429:	t->min = t->c_start;
        -:  430:	
        -:  431:        /* Arm the timer. No flags are set and no old_value will be
        -:  432:	 * retrieved. */
    #####:  433:        rv = timer_settime(t->timer_id, 0, &in, NULL);
call    0 never executed
    #####:  434:	OS_TRAP_IF(rv != 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  435:
        -:  436:	/* Leave the critical section. */
    #####:  437:	os_cs_leave(&tm.mutex);
call    0 never executed
    #####:  438:}
        -:  439:
        -:  440:/**
        -:  441: * os_clock_delete() - remove a periodic timer.
        -:  442: *
        -:  443: * @id:  assigned timer id by os_clock_init().
        -:  444: *
        -:  445: * Return:	None.
        -:  446: **/
function os_clock_delete called 0 returned 0% blocks executed 0%
    #####:  447:void os_clock_delete(int id)
        -:  448:{
        -:  449:	struct tm_elem_s *t;
        -:  450:	int rv;
        -:  451:	
        -:  452:	/* Enter the critical section. */
    #####:  453:	os_cs_enter(&tm.mutex);
call    0 never executed
        -:  454:	
        -:  455:	/* Entry condition. */
    #####:  456:	OS_TRAP_IF(id < 0 || id >= OS_CLOCK_LIMIT);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  457:
        -:  458:	/* Get the pointer to the timer description. */
    #####:  459:	t = &tm.elem[id];
    #####:  460:	OS_TRAP_IF(! t->assigned);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  461:	
        -:  462:	/* Disarm and delete the timer. */
    #####:  463:	rv = timer_delete(t->timer_id);
call    0 never executed
    #####:  464:	OS_TRAP_IF(rv != 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  465:
        -:  466:	/* Release the control semaphore. */
    #####:  467:	os_sem_delete(&t->suspend);
call    0 never executed
        -:  468:	
        -:  469:	/* Release this timer. */
    #####:  470:	t->assigned = 0;
        -:  471:
        -:  472:	/* Leave the critical section. */
    #####:  473:	os_cs_leave(&tm.mutex);
call    0 never executed
    #####:  474:}
        -:  475:
        -:  476:/**
        -:  477: * os_clock_init() - create a periodic timer with a repeating interval of i
        -:  478: * milliseconds.
        -:  479: *
        -:  480: * @name:      timer name.
        -:  481: * @interval:  repeating interval in milliseconds.
        -:  482: *
        -:  483: * Return:	the timer id.
        -:  484: **/
function os_clock_init called 0 returned 0% blocks executed 0%
    #####:  485:int os_clock_init(const char *name, int interval)
        -:  486:{
        -:  487:	struct tm_elem_s *t;
        -:  488:	int i, len, rv;
        -:  489:	
        -:  490:	/* Entry condition. */
    #####:  491:	OS_TRAP_IF(name == NULL || interval < 1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  492:	
        -:  493:	/* Enter the critical section. */
    #####:  494:	os_cs_enter(&tm.mutex);
call    0 never executed
        -:  495:	
        -:  496:	/* Search for a free wait element. */
    #####:  497:	for (i = 0, t = tm.elem; i < OS_CLOCK_LIMIT; i++, t++) {
branch  0 never executed
branch  1 never executed
    #####:  498:		if (! t->assigned)
branch  0 never executed
branch  1 never executed
    #####:  499:			break;
        -:  500:	}
        -:  501:
        -:  502:	/* Test the search result. */
    #####:  503:	OS_TRAP_IF(i >= OS_CLOCK_LIMIT);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  504:
        -:  505:	/* This timer is yours. */
    #####:  506:	os_memset(t, 0, sizeof(struct tm_elem_s));
call    0 never executed
        -:  507:
        -:  508:	/* Update the timer state. */
    #####:  509:	t->id = i;
    #####:  510:	t->assigned = 1;
    #####:  511:	t->interval = interval;
    #####:  512:	os_sem_init(&t->suspend, 0);
call    0 never executed
        -:  513:	
        -:  514:	/* Save the timer name. */
    #####:  515:	len = os_strlen(name);
call    0 never executed
    #####:  516:	OS_TRAP_IF(len >= OS_MAX_NAME_LEN);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  517:	os_memset(t->name, 0, OS_MAX_NAME_LEN);
call    0 never executed
    #####:  518:	os_strcpy(t->name, OS_MAX_NAME_LEN, name);
call    0 never executed
        -:  519:
        -:  520:	/* Install a periodic timer. */
    #####:  521:	tm_create(t);
call    0 never executed
        -:  522:	
        -:  523:	/* Remember the system start time. */
    #####:  524:	rv = gettimeofday(&t->s_start, NULL);
call    0 never executed
    #####:  525:	OS_TRAP_IF(rv != 0);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  526:
        -:  527:	/* Leave the critical section. */
    #####:  528:	os_cs_leave(&tm.mutex);
call    0 never executed
        -:  529:
    #####:  530:	return t->id;
        -:  531:}
        -:  532:
        -:  533:/**
        -:  534: * os_clock_exit() - release the timer resources.
        -:  535: *
        -:  536: * Return:	None.
        -:  537: **/
function os_clock_exit_ called 2 returned 100% blocks executed 89%
        2:  538:void os_clock_exit_(void)
        -:  539:{
        -:  540:	struct tm_elem_s *t;
        -:  541:	int i;
        -:  542:
        -:  543:	/* Enter the critical section. */
        2:  544:	os_cs_enter(&tm.mutex);
call    0 returned 100%
        -:  545:	
        -:  546:	/* Test the state of all timer. */
       10:  547:	for (i = 0, t = tm.elem; i < OS_CLOCK_LIMIT; i++, t++) {
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  548:		/* Test the timer state. */
       8*:  549:		OS_TRAP_IF(t->assigned);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  550:	}
        -:  551:
        -:  552:	/* Leave the critical section. */
        2:  553:	os_cs_leave(&tm.mutex);
call    0 returned 100%
        -:  554:	
        -:  555:	/* Delete the mutex for the critical sections. */
        2:  556:	os_cs_destroy(&tm.mutex);
call    0 returned 100%
        2:  557:}
        -:  558:
        -:  559:/**
        -:  560: * os_clock_init() - initialize the timer resources.
        -:  561: *
        -:  562: * Return:	None.
        -:  563: **/
function os_clock_init_ called 2 returned 100% blocks executed 100%
        2:  564:void os_clock_init_(void)
        -:  565:{
        -:  566:	/* Create the mutex for the critical section in the timer operations. */
        2:  567:	os_cs_init(&tm.mutex);
call    0 returned 100%
        2:  568:}
