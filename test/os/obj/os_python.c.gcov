        -:    0:Source:/home/gerald/github/van/os/os_python.c
        -:    1:// SPDX-License-Identifier: GPL-2.0
        -:    2:
        -:    3:/*
        -:    4: * Python shared memory driver.
        -:    5: *
        -:    6: * Copyright (C) 2021 Gerald Schueller <gerald.schueller@web.de>
        -:    7: */
        -:    8:
        -:    9:/*============================================================================
        -:   10:  IMPORTED INCLUDE REFERENCES
        -:   11:  ============================================================================*/
        -:   12:#include "os_shm.h"      /* Shared memory entry points. */
        -:   13:
        -:   14:/*============================================================================
        -:   15:  EXPORTED INCLUDE REFERENCES
        -:   16:  ============================================================================*/
        -:   17:/*============================================================================
        -:   18:  LOCAL NAME CONSTANTS DEFINITIONS
        -:   19:  ============================================================================*/
        -:   20:#define OS_PY_NAME  "/python"  /* Name of the python shared memory device. */
        -:   21:#define PP          "P-I>"     /* Prompt for the py_int thread. */
        -:   22:
        -:   23:#if defined(USE_OS_RT)
        -:   24:#define PRIO    OS_THREAD_PRIO_HARDRT
        -:   25:#else
        -:   26:#define PRIO    OS_THREAD_PRIO_SOFTRT
        -:   27:#endif
        -:   28:
        -:   29:#define Q_SIZE  OS_THREAD_Q_SIZE
        -:   30:
        -:   31:/*============================================================================
        -:   32:  MACROS
        -:   33:  ============================================================================*/
        -:   34:/*============================================================================
        -:   35:  LOCAL TYPE DEFINITIONS
        -:   36:  ============================================================================*/
        -:   37:/*============================================================================
        -:   38:  LOCAL DATA
        -:   39:  ============================================================================*/
        -:   40:/* Pointer to the OS configuration */
        -:   41:static os_conf_t *os_conf_p;
        -:   42:
        -:   43:/* Python shared memory devices. */
        -:   44:static os_dev_t *os_py_device;
        -:   45:
        -:   46:/*============================================================================
        -:   47:  LOCAL FUNCTION PROTOTYPES
        -:   48:  ============================================================================*/
        -:   49:/*============================================================================
        -:   50:  LOCAL FUNCTIONS
        -:   51:  ============================================================================*/
        -:   52:/**
        -:   53: * py_aio_ulq_add() - send the UL shm message from py to van asynchronously.
        -:   54: *
        -:   55: * dev:       pointer to the shm device.
        -:   56: * count:     size of the UL payload.
        -:   57: * consumed:  if 1, the DL buffer has been released.
        -:   58: *
        -:   59: * Return:	None.
        -:   60: **/
function py_aio_ulq_add called 8 returned 100% blocks executed 83%
        8:   61:static void py_aio_ulq_add(os_dev_t *dev, int count, int consumed)
        -:   62:{
        -:   63:	os_shm_queue_t *q;
        -:   64:	os_shm_msg_t *shm_m;
        -:   65:	int head;
        -:   66:	
        -:   67:	/* Get the pointer of the van shm input queue. */
        8:   68:	q = dev->top.ul_queue;
        -:   69:	
        -:   70:	/* Fill the next free message. */
        8:   71:	head = q->head;
        8:   72:	shm_m = &q->ring[head];
        8:   73:	shm_m->size     = count;
        8:   74:	shm_m->consumed = consumed;
        -:   75:
        -:   76:	/* Increment and test the end of the message list. */
        8:   77:	head++;
        8:   78:	if (head >= OS_SHM_Q_SIZE)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        2:   79:		head = 0;
        -:   80:
       8*:   81:	OS_TRAP_IF(head == q->tail);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        8:   82:	q->head = head;
        -:   83:
        -:   84:	/* Trigger the van_int. */
        8:   85:	os_sem_release(dev->other_int);
call    0 returned 100%
        8:   86:}
        -:   87:
        -:   88:/**
        -:   89: * py_ulq_add() - send the UL shm message from py to van synchronously.
        -:   90: *
        -:   91: * dev:       pointer to the shm device.
        -:   92: * count:     size of the UL payload.
        -:   93: * consumed:  if 1, the DL buffer has been released.
        -:   94: *
        -:   95: * Return:	None.
        -:   96: **/
function py_ulq_add called 8 returned 100% blocks executed 88%
        8:   97:static void py_ulq_add(os_dev_t *dev, int count, int consumed)
        -:   98:{
        -:   99:	os_shm_queue_t *q;
        -:  100:	os_shm_msg_t *shm_m;
        -:  101:	int head;
        -:  102:	
        -:  103:	/* Enter the critical section. */
        8:  104:	os_cs_enter(&dev->top.q_mutex);
call    0 returned 100%
        -:  105:
        -:  106:	/* Get the pointer of the van shm input queue. */
        8:  107:	q = dev->top.ul_queue;
        -:  108:	
        -:  109:	/* Fill the next free message. */
        8:  110:	head = q->head;
        8:  111:	shm_m = &q->ring[head];
        8:  112:	shm_m->size     = count;
        8:  113:	shm_m->consumed = consumed;
        -:  114:
        -:  115:	/* Increment and test the end of the message list. */
        8:  116:	head++;
        8:  117:	if (head >= OS_SHM_Q_SIZE)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        2:  118:		head = 0;
        -:  119:
       8*:  120:	OS_TRAP_IF(head == q->tail);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        8:  121:	q->head = head;
        -:  122:
        -:  123:	/* Trigger the van_int. */
        8:  124:	os_sem_release(dev->other_int);
call    0 returned 100%
        -:  125:
        -:  126:	/* Leave the critical section. */
        8:  127:	os_cs_leave(&dev->top.q_mutex);	
call    0 returned 100%
        8:  128:}
        -:  129:
        -:  130:/**
        -:  131: * py_aio_action() - install the read and write callback for the asynchronous
        -:  132: * operations. The reconfiguration of the async. I/O operations is not
        -:  133: * supported. It is recommended to decide themselves for aio immediately after
        -:  134: * os_open before data transfer starts, in order to avoid deadlocks in the sync.
        -:  135: * operations.
        -:  136: *
        -:  137: * @dev_id:  id of the shared memory device.
        -:  138: * @cb:      pointer to the async. I/O callbacks.
        -:  139: *
        -:  140: * Return:	None.
        -:  141: **/
function py_aio_action called 2 returned 100% blocks executed 86%
        2:  142:void py_aio_action(int dev_id, os_aio_cb_t *cb)
        -:  143:{
        -:  144:	os_dev_t *p;
        -:  145:	
        -:  146:	/* Entry conditon. */
        2:  147:	p = os_py_device;
       2*:  148:	OS_TRAP_IF(p == NULL || p->id != dev_id ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
call   10 never executed
        -:  149:		   cb == NULL || cb->read_cb == NULL || cb->write_cb == NULL);
        -:  150:
        -:  151:	/* Enter the critical section. */
        2:  152:	os_cs_enter(&p->aio_mutex);
call    0 returned 100%
        -:  153:
        -:  154:	/* Extended entry conditon. */
       2*:  155:	OS_TRAP_IF(p->aio_use ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
call    8 never executed
        -:  156:		   p->pending_ul || p->sync_read || p->sync_write);
        -:  157:
        -:  158:	/* Copy the async. I/O operations. */
        2:  159:	p->aio_cb = *cb;
        -:  160:
        -:  161:	/* Activate the async. I/O transfer. */
        2:  162:	atomic_store(&p->aio_use, 1);
        -:  163:
        -:  164:	/* Leave the critical section. */
        2:  165:	os_cs_leave(&p->aio_mutex);	
call    0 returned 100%
        2:  166:}
        -:  167:
        -:  168:/**
        -:  169: * py_aio_write() - this async. I/O operation triggers the py irq, to start or
        -:  170: * restart the send procedure.
        -:  171: *
        -:  172: * @dev_id:  id of the shared memory device.
        -:  173: *
        -:  174: * Return:	None.
        -:  175: **/
function py_aio_write called 2 returned 100% blocks executed 78%
        2:  176:void py_aio_write(int dev_id)
        -:  177:{
        -:  178:	os_dev_t *p;
        -:  179:	
        -:  180:	/* Entry conditon. */
        2:  181:	p = os_py_device;
       2*:  182:	OS_TRAP_IF(p == NULL || p->id != dev_id);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  183:
        -:  184:	/* Enter the critical section. */
        2:  185:	os_cs_enter(&p->aio_mutex);
call    0 returned 100%
        -:  186:
        -:  187:	/* Extended entry conditon. */
       2*:  188:	OS_TRAP_IF(! p->aio_use);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  189:
        -:  190:	/* Update the write trigger. */
        2:  191:	atomic_store(&p->aio_wr_trigger, 1);
        -:  192:
        -:  193:	/* Resume the py interrupt handler. */
        2:  194:	os_sem_release(p->my_int);
call    0 returned 100%
        -:  195:
        -:  196:	/* Leave the critical section. */
        2:  197:	os_cs_leave(&p->aio_mutex);	
call    0 returned 100%
        2:  198:}
        -:  199:
        -:  200:/**
        -:  201: * py_aio_read() - this async. I/O operation triggers the py irq, to start or
        -:  202: * restart the receive procedure.
        -:  203: *
        -:  204: * @dev_id:  id of the shared memory device.
        -:  205: *
        -:  206: * Return:	None.
        -:  207: **/
function py_aio_read called 2 returned 100% blocks executed 78%
        2:  208:void py_aio_read(int dev_id)
        -:  209:{
        -:  210:	os_dev_t *p;
        -:  211:	
        -:  212:	/* Entry conditon. */
        2:  213:	p = os_py_device;
       2*:  214:	OS_TRAP_IF(p == NULL || p->id != dev_id);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  215:
        -:  216:	/* Enter the critical section. */
        2:  217:	os_cs_enter(&p->aio_mutex);
call    0 returned 100%
        -:  218:
        -:  219:	/* Extended entry conditon. */
       2*:  220:	OS_TRAP_IF(! p->aio_use);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  221:
        -:  222:	/* Update the read trigger. */
        2:  223:	atomic_store(&p->aio_rd_trigger, 1);
        -:  224:
        -:  225:	/* Resume the py interrupt handler. */
        2:  226:	os_sem_release(p->my_int);
call    0 returned 100%
        -:  227:
        -:  228:	/* Leave the critical section. */
        2:  229:	os_cs_leave(&p->aio_mutex);	
call    0 returned 100%
        2:  230:}
        -:  231:
        -:  232:/**
        -:  233: * py_read() - py waits for incoming payload.
        -:  234: *
        -:  235: * @dev_id:  id of the shared memory device.
        -:  236: * @buf:     pointer to the received payload.
        -:  237: * @count:   size of the destination buffer.
        -:  238: *
        -:  239: * Return:	number of the received bytes.
        -:  240: **/
function py_read called 2 returned 100% blocks executed 89%
        2:  241:int py_read(int dev_id, char *buf, int count)
        -:  242:{
        -:  243:	os_shm_top_t *top;
        -:  244:	os_dev_t *p;
        -:  245:	int n;
        -:  246:
        -:  247:	/* Entry conditon. */
        2:  248:	p = os_py_device;
       2*:  249:	OS_TRAP_IF(p == NULL || p->id != dev_id || ! p->init ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
call   10 never executed
        -:  250:		   buf == NULL || count < 1);
        -:  251:
        -:  252:	/* Get the pointer to the shm topology. */
        2:  253:	top = &p->top;
        -:  254:	
        -:  255:	/* Enter the critical section. */
        2:  256:	os_cs_enter(&p->read_mutex);
call    0 returned 100%
        -:  257:
        -:  258:	/* Define the read method. */
        2:  259:	atomic_store(&p->sync_read, 1);
        -:  260:
        -:  261:	/* Wait for the DL payload. */
        -:  262:	for(;;) {
        -:  263:		/* Get the number of the received bytes. */
        3:  264:		n = atomic_exchange(&top->dl_count, 0);
        -:  265:
        -:  266:		/* Test the number of the received bytes. */
        3:  267:		if (n < 1) { 
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -:  268:			/* Suspend the read user. */
        1:  269:			os_sem_wait(&p->suspend_reader);
call    0 returned 100%
        1:  270:			continue;
        -:  271:		}
        -:  272:
        2:  273:		break;
        -:  274:	}
        -:  275:	
        -:  276:	/* Release the sync. read operation. */
        2:  277:	atomic_store(&p->sync_read, 0);
        -:  278:
        -:  279:	/* Test the user buffer. */
       2*:  280:	OS_TRAP_IF(count < n);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  281:	
        -:  282:	/* Copy the received payload. */
        2:  283:	os_memcpy(buf, count, top->dl_start, n);
call    0 returned 100%
        -:  284:
        -:  285:	/* Release the pending DL buffer. */
        2:  286:	py_ulq_add(p, 0, 1);
call    0 returned 100%
        -:  287:	
        -:  288:	/* Leave the critical section. */
        2:  289:	os_cs_leave(&p->read_mutex);	
call    0 returned 100%
        -:  290:
        2:  291:	return n;
        -:  292:}
        -:  293:
        -:  294:/**
        -:  295: * py_zread() - py waits for incoming payload. With each successiv call.
        -:  296: * The reference to the previous call is released automatically.
        -:  297: *
        -:  298: * @dev_id:  id of the shared memory device.
        -:  299: * @buf:     pointer to the received payload.
        -:  300: * @count:   size of the destination buffer.
        -:  301: *
        -:  302: * Return:	number of the received bytes.
        -:  303: **/
function py_zread called 4 returned 100% blocks executed 90%
        4:  304:static int py_zread(int dev_id, char **buf, int count)
        -:  305:{
        -:  306:	os_shm_top_t *top;
        -:  307:	os_dev_t *p;
        -:  308:	int pending_dl, n;
        -:  309:	
        -:  310:	/* Entry conditon. */
        4:  311:	p = os_py_device;
       4*:  312:	OS_TRAP_IF(p == NULL || p->id != dev_id);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  313:
        -:  314:	/* Entry condition. */
       4*:  315:	OS_TRAP_IF(! p->init);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  316:
        -:  317:	/* Get the pointer to the shm topology. */
        4:  318:	top = &p->top;
        -:  319:	
        -:  320:	/* Enter the critical section. */
        4:  321:	os_cs_enter(&p->read_mutex);
call    0 returned 100%
        -:  322:
        -:  323:	/* If the DL payload is, send the shm message to van. */
        4:  324:	pending_dl = atomic_exchange(&p->pending_dl, 0);
        4:  325:	if (pending_dl)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        2:  326:		py_ulq_add(p, 0, 1);
call    0 returned 100%
        -:  327:	
        -:  328:	/* Test the buffer state. */
        4:  329:	if (buf == NULL || count < 1) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  330:		/* Leave the critical section. */
        2:  331:		os_cs_leave(&p->read_mutex);	
call    0 returned 100%
        2:  332:		return 0;
        -:  333:	}
        -:  334:	
        -:  335:	/* Define the read method. */
        2:  336:	atomic_store(&p->sync_read, 1);
        -:  337:
        -:  338:	/* Wait for the DL payload. */
        -:  339:	for(;;) {
        -:  340:		/* Get the number of the received bytes. */
        3:  341:		n = atomic_exchange(&top->dl_count, 0);
        -:  342:
        -:  343:		/* Test the number of the received bytest. */
        3:  344:		if (n < 1) { 
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -:  345:			/* Suspend the read user. */
        1:  346:			os_sem_wait(&p->suspend_reader);
call    0 returned 100%
        1:  347:			continue;
        -:  348:		}
        -:  349:
        2:  350:		break;
        -:  351:	}
        -:  352:	
        -:  353:	/* Release the sync. read operation. */
        2:  354:	atomic_store(&p->sync_read, 0);
        -:  355:
        -:  356:	/* Get the pointer to the received payload. */
        2:  357:	*buf = top->dl_start;
        2:  358:	atomic_store(&p->pending_dl, 1);
        -:  359:
        -:  360:	/* Leave the critical section. */
        2:  361:	os_cs_leave(&p->read_mutex);	
call    0 returned 100%
        -:  362:
        2:  363:	return n;
        -:  364:}
        -:  365:
        -:  366:/**
        -:  367: * py_write() - send the UL payload to van and suspend the caller until the
        -:  368: * payload has been processed.
        -:  369: *
        -:  370: * @dev_id:  id of the shared memory device.
        -:  371: * @buf:     pointer to the payload.
        -:  372: * @count:   size of the payload.
        -:  373: *
        -:  374: * Return:	None.
        -:  375: **/
function py_write called 4 returned 100% blocks executed 81%
        4:  376:static void py_write (int dev_id, char *buf, int count)
        -:  377:{
        -:  378:	os_shm_top_t *top;
        -:  379:	os_dev_t *p;
        -:  380:
        -:  381:	/* Entry conditon. */
        4:  382:	p = os_py_device;
       4*:  383:	OS_TRAP_IF(p == NULL || p->id != dev_id || buf == NULL || count < 1);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
call    8 never executed
        -:  384:
        -:  385:	/* Entry condition. */
       4*:  386:	OS_TRAP_IF(! p->init);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  387:
        -:  388:	/* Get the pointer to the shm topology and to the py input queue. */
        4:  389:	top = &p->top;
        -:  390:	
        -:  391:	/* Enter the critical section. */
        4:  392:	os_cs_enter(&p->write_mutex);
call    0 returned 100%
        -:  393:
        -:  394:	/* XXX Test the state of the UL buffer: py->van. */
       4*:  395:	OS_TRAP_IF(top->ul_size < count || p->pending_ul);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  396:
        -:  397:	/* Change the UL state. */
        4:  398:	atomic_store(&p->pending_ul, 1);
        4:  399:	atomic_store(&p->sync_write, 1);
        -:  400:
        -:  401:	/* Fill the UL buffer. */
        4:  402:	os_memcpy(top->ul_start, OS_BUF_SIZE, buf, count);
call    0 returned 100%
        -:  403:
        -:  404:	/* Save the size of the payload. */
        4:  405:	atomic_store(&top->ul_count, count);
        -:  406:		
        -:  407:	/* Send the shm message to van. */
        4:  408:	py_ulq_add(p, count, 0);
call    0 returned 100%
        -:  409:
        -:  410:	/* Suspend the caller until the action is executed. */
        4:  411:	os_sem_wait(&p->suspend_writer);
call    0 returned 100%
        -:  412:
        -:  413:	/* Leave the critical section. */
        4:  414:	os_cs_leave(&p->write_mutex);	
call    0 returned 100%
        4:  415:}
        -:  416:
        -:  417:#if defined(OS_CLOSE_NET)
        -:  418:/**
        -:  419: * py_exit_exec() - the py_int thread shall not be suspended with named
        -:  420: * py_int semphore.
        -:  421: *
        -:  422: * @msg:  generic input message.
        -:  423: *
        -:  424: * Return:	None.
        -:  425: **/
        -:  426:static void py_exit_exec(os_queue_elem_t *msg)
        -:  427:{
        -:  428:	OS_TRACE(("%s [s:ready, m:py-exit] -> [s:ready]\n", PP));
        -:  429:}
        -:  430:#endif
        -:  431:
        -:  432:/**
        -:  433: * py_close() - the python process shall call this function to remove the
        -:  434: * shared memory ressources.
        -:  435: *
        -:  436: * @dev_id:  id of the py shm device.
        -:  437: *
        -:  438: * Return:	None.
        -:  439: **/
function py_close called 2 returned 100% blocks executed 88%
        2:  440:static void py_close(int dev_id)
        -:  441:{
        -:  442:#if defined(OS_CLOSE_NET)
        -:  443:	os_queue_elem_t msg;
        -:  444:#endif
        -:  445:	os_dev_t *p;
        -:  446:	
        -:  447:	/* Entry conditon. */
        2:  448:	p = os_py_device;
       2*:  449:	OS_TRAP_IF(p == NULL || p->id != dev_id);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  450:
        -:  451:	/* Change the state of the shm area. */
        2:  452:	p->init = 0;
        -:  453:	
        -:  454:#if defined(OS_CLOSE_NET)
        -:  455:	/* Define the py_int terminate message. */
        -:  456:	os_memset(&msg, 0, sizeof(msg));
        -:  457:	msg.param = p->thread;
        -:  458:	msg.cb    = py_exit_exec;
        -:  459:	OS_SEND(p->thread, &msg, sizeof(msg));
        -:  460:#endif
        -:  461:	/* Resume the py_int thread, to terminate it. */
        2:  462:	atomic_store(&p->down, 1);
        2:  463:	os_sem_release(p->my_int);
call    0 returned 100%
        -:  464:	
        -:  465:	/* Delete the py interrupt handler. */
        2:  466:	os_thread_destroy(p->thread);
call    0 returned 100%
        -:  467:	
        -:  468:	/* Delete the access and the mapping to the shared memory. */
        2:  469:	os_shm_close(p);
call    0 returned 100%
        -:  470:	
        -:  471:	/* Free the py shm device. */
        2:  472:	OS_FREE(os_py_device);
call    0 returned 100%
        2:  473:}
        -:  474:
        -:  475:/**
        -:  476: * py_int_write() - resume the syspend caller in write or request UL data
        -:  477: * from the aio user.
        -:  478: *
        -:  479: * @p:  pointer to the py device state.
        -:  480: * @t:  pointer to the shared memory topology.
        -:  481: *
        -:  482: * Return:	None.
        -:  483: **/
function py_int_write called 9 returned 100% blocks executed 91%
        9:  484:static void py_int_write(os_dev_t *p, os_shm_top_t *t)
        -:  485:{
        -:  486:	int aio_use, sync, pending_ul, count;
        -:  487:	
        -:  488:	/* Test the aio status request. */
        9:  489:	aio_use = atomic_load(&p->aio_use);
        9:  490:	if (! aio_use) {
branch  0 taken 44% (fallthrough)
branch  1 taken 56%
        -:  491:		/* Test the write method. */
        4:  492:		sync = atomic_exchange(&p->sync_write, 0);
        4:  493:		if (sync)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4:  494:			os_sem_release(&p->suspend_writer);
call    0 returned 100%
        -:  495:		
        4:  496:		return;
        -:  497:	}
        -:  498:
        -:  499:	/* Reset the write trigger. */
        5:  500:	atomic_store(&p->aio_wr_trigger, 0);
        -:  501:
        -:  502:	/* Test the release status of the UL buffer, which van has not
        -:  503:	 * consumed. */
        5:  504:	pending_ul = atomic_load(&p->pending_ul);
        5:  505:	if (pending_ul)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  506:		return;
        -:  507:	
        -:  508:	/* Request UL data from the aio user. */
        5:  509:	count = p->aio_cb.write_cb(p->id, t->ul_start, OS_BUF_SIZE);
call    0 returned 100%
        5:  510:	if (count < 1)
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        1:  511:		return;
        -:  512:
        -:  513:	/* Change the UL state. */
        4:  514:	atomic_store(&p->pending_ul, 1);
        -:  515:					
        -:  516:	/* Save the size of the payload. */
        4:  517:	atomic_store(&t->ul_count, count);
        -:  518:
        -:  519:	/* Send the shm message to van. */
        4:  520:	py_aio_ulq_add(p, count, 0);
call    0 returned 100%
        -:  521:}
        -:  522:
        -:  523:/**
        -:  524: * py_int_read() - pass the DL data to the async. caller or resume the
        -:  525: * suspended caller in read or zread.
        -:  526: *
        -:  527: * @p:      pointer to the py device state.
        -:  528: * @t:      pointer to the shared memory topology.
        -:  529: * @count:  number of the pending DL characters.
        -:  530: *
        -:  531: * Return:	None.
        -:  532: **/
function py_int_read called 9 returned 100% blocks executed 81%
        9:  533:static void py_int_read(os_dev_t *p, os_shm_top_t *t, int count)
        -:  534:{
        -:  535:	int aio_use, sync, consumed;
        -:  536:	
        -:  537:	/* Test the aio status. */
        9:  538:	aio_use = atomic_load(&p->aio_use);
        9:  539:	if (aio_use) {
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
        -:  540:		/* Reset the read trigger. */
        5:  541:		atomic_store(&p->aio_rd_trigger, 0);
        -:  542:
        -:  543:		/* Test the number of the pending DL characters. */
        5:  544:		if (count < 1)
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        1:  545:			return;
        -:  546:		
        -:  547:		/* Pass the DL data to the aio user. */
        4:  548:		consumed = p->aio_cb.read_cb(p->id, t->dl_start, count);
call    0 returned 100%
        -:  549:
        -:  550:		/* Update the DL state. */
       4*:  551:		OS_TRAP_IF(consumed > count || consumed < 0);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        4:  552:		if (consumed != count) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  553:			atomic_store(&t->dl_count, count - consumed);
    #####:  554:			return;
        -:  555:		}
        -:  556:		
        -:  557:		/* Reset the DL state. */
        4:  558:		atomic_store(&t->dl_count, 0);
        -:  559:
        -:  560:		/* Release the pending DL buffer. */
        4:  561:		py_aio_ulq_add(p, 0, 1);
call    0 returned 100%
        -:  562:	}
        -:  563:	else {
        -:  564:		/* Save the number of the received DL bytes. */
        4:  565:		atomic_store(&t->dl_count, count);
        -:  566:			
        -:  567:		/* Test the read method. */
        4:  568:		sync = atomic_exchange(&p->sync_read, 0);
        -:  569:
       4*:  570:		OS_TRACE(("%s dl_count=%d, read=%d\n", PP, t->dl_count, sync));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  571:
        4:  572:		if (sync)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        2:  573:			os_sem_release(&p->suspend_reader);
call    0 returned 100%
        -:  574:	}
        -:  575:}
        -:  576:
        -:  577:/**
        -:  578: * py_int_exec() - the py_int thread waits for the py_int triggered by van or
        -:  579: * internally to process a send order.
        -:  580: *
        -:  581: * @msg:  generic input message.
        -:  582: *
        -:  583: * Return:	None.
        -:  584: **/
function py_int_exec called 2 returned 100% blocks executed 89%
        2:  585:static void py_int_exec(os_queue_elem_t *msg)
        -:  586:{
        -:  587:	os_shm_queue_t *q;
        -:  588:	os_shm_msg_t *shm_m;
        -:  589:	os_shm_top_t *t;
        -:  590:	os_dev_t *p;
        -:  591:	int down;
        -:  592:
        -:  593:	/* Get the address of the py shared memory state. */
        2:  594:	p = os_py_device;
        -:  595:
        -:  596:	/* Get the pointer to the shm topology and to the py input queue. */
        2:  597:	t = &p->top;
        2:  598:	q = t->dl_queue;
        -:  599:
        -:  600:	/* Loop thru the py interrupts triggered by van. */
        -:  601:	for(;;) {
        -:  602:		/* Test the access method to the python device. */
       21:  603:		if (p->aio_use) {
branch  0 taken 52% (fallthrough)
branch  1 taken 48%
        -:  604:			/* Test the DL payload state from van and trigger the
        -:  605:			 *  user actions. */
       11:  606:			if (p->aio_rd_trigger)
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
        1:  607:				py_int_read(p, t, t->dl_count);
call    0 returned 100%
        -:  608:			
        -:  609:			/* Test the aio status, request data from the user and
        -:  610:			 *  inform van. */
       11:  611:			if (p->aio_wr_trigger)
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
        2:  612:				py_int_write(p, t);
call    0 returned 100%
        -:  613:		}		
        -:  614:
      21*:  615:		OS_TRACE(("%s [s:ready, m:py-int] -> [s:suspended]\n", PP));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  616:
        -:  617:		/* Wait for the py_int trigger. */
       21:  618:		os_sem_wait(p->my_int);
call    0 returned 100%
        -:  619:
        -:  620:		/* Test the thread state. */
       21:  621:		down = atomic_load(&p->down);
       21:  622:		if (down) {
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
       2*:  623:			OS_TRACE(("%s [s:suspended, m:py-int] -> [s:down]\n", PP));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        2:  624:			return;
        -:  625:		} else {
      19*:  626:			OS_TRACE(("%s [s:suspended, m:py-int] -> [s:ready]\n", PP));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  627:		}
        -:  628:
        -:  629:		/* Analyze the py shm input queue. */
       34:  630:		while (q->tail != q->head) {
branch  0 taken 44%
branch  1 taken 56% (fallthrough)
       15:  631:			shm_m = &q->ring[q->tail];
        -:  632:			
        -:  633:			/* Test the DL payload state from van. */
       15:  634:			if (shm_m->size > 0) {
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
        -:  635:				/* Test the DL payload state from van and trigger the user actions. */
        8:  636:				py_int_read(p, t, shm_m->size);
call    0 returned 100%
        -:  637:			}
        -:  638:
        -:  639:			/* Test the state of the sent UL playload from py to van. */
       15:  640:			if (shm_m->consumed) {
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
        -:  641:				/* Release the UL transfer. */
        7:  642:				atomic_store(&p->pending_ul, 0);
        -:  643:
        -:  644:				/* Trigger the py user UL actions. */
        7:  645:				py_int_write(p, t);
call    0 returned 100%
        -:  646:			}
        -:  647:		
        -:  648:			/* Increment and test the start of the message list. */
       15:  649:			q->tail++;
       15:  650:			if (q->tail >= OS_SHM_Q_SIZE)
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        3:  651:				q->tail = 0;
        -:  652:		}
        -:  653:	}
        -:  654:}
        -:  655:
        -:  656:/**
        -:  657: * py_open() - the python process shall call this function to create the
        -:  658: * shared memory device.
        -:  659: *
        -:  660: * @name:  pointer to the van device name.
        -:  661: *
        -:  662: * Return:	None.
        -:  663: **/
function py_open called 2 returned 100% blocks executed 83%
        2:  664:static int py_open(char *name)
        -:  665:{
        -:  666:	os_queue_elem_t msg;
        -:  667:	os_dev_t *p;
        -:  668:
        -:  669:	/* Entry condition. */
       2*:  670:	OS_TRAP_IF(name == NULL || os_strcmp(name, OS_PY_NAME) != 0);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:  671:
        -:  672:	/* Allocate the van device state. */
        2:  673:	p = os_py_device = OS_MALLOC(sizeof(os_dev_t));
call    0 returned 100%
        2:  674:	os_memset(p, 0, sizeof(os_dev_t));
call    0 returned 100%
        -:  675:
        -:  676:	/* Save the device identificaton. */
        2:  677:	p->id = OS_DEV_PY;
        2:  678:	p->name = OS_PY_NAME;
        2:  679:	p->file_name = OS_SHM_FILE;
        -:  680:
        -:  681:	/* Save the interrupt names. */
        2:  682:	p->my_int_name    = OS_PY_INT;
        2:  683:	p->other_int_name = OS_VAN_INT;
        -:  684:	
        -:  685:	/* Get the reference to the python semaphore. */
        2:  686:	p->my_int = sem_open(OS_PY_INT, O_CREAT);
call    0 returned 100%
       2*:  687:	OS_TRAP_IF(p->my_int == SEM_FAILED);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  688:	
        -:  689:	/* Get the reference to the van semaphore. */
        2:  690:	p->other_int = sem_open(OS_VAN_INT, O_CREAT);
call    0 returned 100%
       2*:  691:	OS_TRAP_IF(p->other_int == SEM_FAILED);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  692:	
        -:  693:	/* Map the file into shared memory. */
        2:  694:	os_shm_open(p);
call    0 returned 100%
        -:  695:	
        -:  696:	/* Install the py interrupt handler/thread. */
        2:  697:	p->thread = os_thread_create("py_int", PRIO, Q_SIZE);	
call    0 returned 100%
        -:  698:	
        -:  699:	/* Change the state of the shm area. */
        2:  700:	p->init = 1;
        -:  701:	
        -:  702:	/* Start with processing of the py_int. */
        2:  703:	os_memset(&msg, 0, sizeof(msg));
call    0 returned 100%
        2:  704:	msg.param = p->thread;
        2:  705:	msg.cb    = py_int_exec;
        2:  706:	OS_SEND(p->thread, &msg, sizeof(msg));
call    0 returned 100%
        -:  707:	
        2:  708:	return OS_DEV_PY;
        -:  709:}
        -:  710:
        -:  711:/*============================================================================
        -:  712:  EXPORTED FUNCTIONS
        -:  713:  ============================================================================*/
        -:  714:/**
        -:  715: * os_py_ripcord() - release critical van device resources.
        -:  716: *
        -:  717: * @coverage:  if 0, release critical device resoures.
        -:  718: *
        -:  719: * Return:	None.
        -:  720: **/
function os_py_ripcord called 2 returned 100% blocks executed 23%
        2:  721:void os_py_ripcord(int coverage)
        -:  722:{
        -:  723:	os_dev_t *p;
        -:  724:
        -:  725:	/* Entry conditon. */
        2:  726:	p = os_py_device;
        -:  727:
        -:  728:	/* Test the van device state. */
       2*:  729:	if (p == NULL || coverage)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        2:  730:		return;
        -:  731:
        -:  732:	/* Remove the reference to the python semaphore. */
    #####:  733:	if (p->my_int)
branch  0 never executed
branch  1 never executed
    #####:  734:		sem_close(p->my_int);
call    0 never executed
        -:  735:	
        -:  736:	/* Remove the reference to the van semaphore. */
    #####:  737:	if (p->other_int)
branch  0 never executed
branch  1 never executed
    #####:  738:		sem_close(p->other_int);
call    0 never executed
        -:  739:
        -:  740:	/* Test the file descriptor of the shared memory file. */
    #####:  741:	if (p->fd == 0)
branch  0 never executed
branch  1 never executed
    #####:  742:		return;
        -:  743:
        -:  744:	/* Delete the mapping of the shared memory area. */
    #####:  745:	if (p->start != 0)
branch  0 never executed
branch  1 never executed
    #####:  746:		munmap(p->start, p->size);
call    0 never executed
        -:  747:
        -:  748:	/* Close the shared memory file. */
    #####:  749:	close(p->fd);
call    0 never executed
        -:  750:}
        -:  751:
        -:  752:/**
        -:  753: * os_py_exit() - test the state of the shared memory devices.
        -:  754: *
        -:  755: * Return:	None.
        -:  756: **/
function os_py_exit called 2 returned 100% blocks executed 67%
        2:  757:void os_py_exit(void)
        -:  758:{
       2*:  759:	OS_TRAP_IF(os_py_device != NULL);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        2:  760:}
        -:  761:
        -:  762:/**
        -:  763: * os_py_init() - request the entry points for the python shared memory device.
        -:  764: *
        -:  765: * @conf:  pointer to the trace configuration.
        -:  766: * @op:    pointer to the entry points of the shm device.
        -:  767: *
        -:  768: * Return:	None.
        -:  769: **/
function os_py_init called 2 returned 100% blocks executed 100%
        2:  770:void os_py_init(os_conf_t *conf, os_dev_ops_t *op)
        -:  771:{
        -:  772:	/* Save the reference to the OS configuration. */
        2:  773:	os_conf_p = conf;
        -:  774:
        -:  775:	/* Save the py shared memory operations. */
        2:  776:	op->device_name = OS_PY_NAME;
        2:  777:	op->device_id   = OS_DEV_PY;
        2:  778:	op->open        = py_open;
        2:  779:	op->close       = py_close;
        2:  780:	op->write       = py_write;
        2:  781:	op->zread       = py_zread;
        2:  782:	op->read        = py_read;
        2:  783:	op->aio_action  = py_aio_action;
        2:  784:	op->aio_write   = py_aio_write;
        2:  785:	op->aio_read    = py_aio_read;
        2:  786:}
