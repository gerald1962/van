        -:    0:Source:/home/gerald/github/van/os/os_van.c
        -:    1:// SPDX-License-Identifier: GPL-2.0
        -:    2:
        -:    3:/*
        -:    4: * Van shared memory driver.
        -:    5: *
        -:    6: * Copyright (C) 2021 Gerald Schueller <gerald.schueller@web.de>
        -:    7: */
        -:    8:
        -:    9:/*============================================================================
        -:   10:  IMPORTED INCLUDE REFERENCES
        -:   11:  ============================================================================*/
        -:   12:#include "os_shm.h"      /* Shared memory entry points. */
        -:   13:
        -:   14:/*============================================================================
        -:   15:  EXPORTED INCLUDE REFERENCES
        -:   16:  ============================================================================*/
        -:   17:/*============================================================================
        -:   18:  LOCAL NAME CONSTANTS DEFINITIONS
        -:   19:  ============================================================================*/
        -:   20:#define OS_VAN_NAME  "/van"  /* Name of the van shared memory device. */
        -:   21:#define VP  "V-I>"           /* Prompt for the van_int thread. */
        -:   22:
        -:   23:#if defined(USE_OS_RT)
        -:   24:#define PRIO    OS_THREAD_PRIO_HARDRT
        -:   25:#else
        -:   26:#define PRIO    OS_THREAD_PRIO_SOFTRT
        -:   27:#endif
        -:   28:
        -:   29:#define Q_SIZE  OS_THREAD_Q_SIZE
        -:   30:
        -:   31:/*============================================================================
        -:   32:  MACROS
        -:   33:  ============================================================================*/
        -:   34:/*============================================================================
        -:   35:  LOCAL TYPE DEFINITIONS
        -:   36:  ============================================================================*/
        -:   37:/*============================================================================
        -:   38:  LOCAL DATA
        -:   39:  ============================================================================*/
        -:   40:/* Pointer to the OS configuration */
        -:   41:static os_conf_t *os_conf_p;
        -:   42:
        -:   43:/* Van shared memory devices. */
        -:   44:static os_dev_t *os_van_device;
        -:   45:
        -:   46:/*============================================================================
        -:   47:  LOCAL FUNCTION PROTOTYPES
        -:   48:  ============================================================================*/
        -:   49:/*============================================================================
        -:   50:  LOCAL FUNCTIONS
        -:   51:  ============================================================================*/
        -:   52:/**
        -:   53: * van_aio_dlq_add() - send the DL shm message from van to py asynchronously.
        -:   54: *
        -:   55: * dev:       pointer to the shm device.
        -:   56: * count:     size of the DL payload.
        -:   57: * consumed:  if 1, the UL buffer has been released.
        -:   58: *
        -:   59: * Return:	None.
        -:   60: **/
function van_aio_dlq_add called 8 returned 100% blocks executed 83%
        8:   61:static void van_aio_dlq_add(os_dev_t *dev, int count, int consumed)
        -:   62:{
        -:   63:	os_shm_queue_t *q;
        -:   64:	os_shm_msg_t *shm_m;
        -:   65:	int head;
        -:   66:	
        -:   67:	/* Get the pointer of the py shm input queue. */
        8:   68:	q = dev->top.dl_queue;
        -:   69:	
        -:   70:	/* Fill the next free message. */
        8:   71:	head = q->head;
        8:   72:	shm_m = &q->ring[head];
        8:   73:	shm_m->size     = count;
        8:   74:	shm_m->consumed = consumed;
        -:   75:
        -:   76:	/* Increment and test the end of the message list. */
        8:   77:	head++;
        8:   78:	if (head >= OS_SHM_Q_SIZE)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        2:   79:		head = 0;
        -:   80:
       8*:   81:	OS_TRAP_IF(head == q->tail);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        8:   82:	q->head = head;
        -:   83:
        -:   84:	/* Trigger the py_int. */
        8:   85:	os_sem_release(dev->other_int);
call    0 returned 100%
        8:   86:}
        -:   87:
        -:   88:/**
        -:   89: * van_dlq_add() - send the DL shm message from van to py synchronously.
        -:   90: *
        -:   91: * dev:       pointer to the shm device.
        -:   92: * count:     size of the DL payload.
        -:   93: * consumed:  if 1, the UL buffer has been released.
        -:   94: *
        -:   95: * Return:	None.
        -:   96: **/
function van_dlq_add called 8 returned 100% blocks executed 88%
        8:   97:static void van_dlq_add(os_dev_t *dev, int count, int consumed)
        -:   98:{
        -:   99:	os_shm_queue_t *q;
        -:  100:	os_shm_msg_t *shm_m;
        -:  101:	int head;
        -:  102:	
        -:  103:	/* Enter the critical section. */
        8:  104:	os_cs_enter(&dev->top.q_mutex);
call    0 returned 100%
        -:  105:
        -:  106:	/* Get the pointer of the py shm input queue. */
        8:  107:	q = dev->top.dl_queue;
        -:  108:	
        -:  109:	/* Fill the next free message. */
        8:  110:	head = q->head;
        8:  111:	shm_m = &q->ring[head];
        8:  112:	shm_m->size     = count;
        8:  113:	shm_m->consumed = consumed;
        -:  114:
        -:  115:	/* Increment and test the end of the message list. */
        8:  116:	head++;
        8:  117:	if (head >= OS_SHM_Q_SIZE)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        2:  118:		head = 0;
        -:  119:
       8*:  120:	OS_TRAP_IF(head == q->tail);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        8:  121:	q->head = head;
        -:  122:
        -:  123:	/* Trigger the py_int. */
        8:  124:	os_sem_release(dev->other_int);
call    0 returned 100%
        -:  125:
        -:  126:	/* Leave the critical section. */
        8:  127:	os_cs_leave(&dev->top.q_mutex);	
call    0 returned 100%
        8:  128:}
        -:  129:
        -:  130:/**
        -:  131: * van_aio_action() - install the read and write callback for the asynchronous
        -:  132: * operations. The reconfiguration of the async. I/O operations is not
        -:  133: * supported. It is recommended to decide themselves for aio immediately after
        -:  134: * os_open before data transfer starts, in order to avoid deadlocks in the sync.
        -:  135: * operations.
        -:  136: *
        -:  137: * @dev_id:  id of the shared memory device.
        -:  138: * @cb:      pointer to the async. I/O callbacks.
        -:  139: *
        -:  140: * Return:	None.
        -:  141: **/
function van_aio_action called 2 returned 100% blocks executed 86%
        2:  142:void van_aio_action(int dev_id, os_aio_cb_t *cb)
        -:  143:{
        -:  144:	os_dev_t *v;
        -:  145:	
        -:  146:	/* Entry conditon. */
        2:  147:	v = os_van_device;
       2*:  148:	OS_TRAP_IF(v == NULL || v->id != dev_id ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
call   10 never executed
        -:  149:		   cb == NULL || cb->read_cb == NULL || cb->write_cb == NULL);
        -:  150:
        -:  151:	/* Enter the critical section. */
        2:  152:	os_cs_enter(&v->aio_mutex);
call    0 returned 100%
        -:  153:
        -:  154:	/* Extended entry conditon. */
       2*:  155:	OS_TRAP_IF(v->aio_use ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
call    8 never executed
        -:  156:		   v->pending_dl || v->sync_read || v->sync_write);
        -:  157:
        -:  158:	/* Copy the async. I/O operations. */
        2:  159:	v->aio_cb = *cb;
        -:  160:
        -:  161:	/* Activate the async. I/O transfer. */
        2:  162:	atomic_store(&v->aio_use, 1);
        -:  163:
        -:  164:	/* Leave the critical section. */
        2:  165:	os_cs_leave(&v->aio_mutex);	
call    0 returned 100%
        2:  166:}
        -:  167:
        -:  168:/**
        -:  169: * van_aio_write() - this async. I/O operation triggers the py irq, to start or
        -:  170: * restart the send procedure.
        -:  171: *
        -:  172: * @dev_id:  id of the shared memory device.
        -:  173: *
        -:  174: * Return:	None.
        -:  175: **/
function van_aio_write called 2 returned 100% blocks executed 78%
        2:  176:void van_aio_write(int dev_id)
        -:  177:{
        -:  178:	os_dev_t *v;
        -:  179:	
        -:  180:	/* Entry conditon. */
        2:  181:	v = os_van_device;
       2*:  182:	OS_TRAP_IF(v == NULL || v->id != dev_id);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  183:
        -:  184:	/* Enter the critical section. */
        2:  185:	os_cs_enter(&v->aio_mutex);
call    0 returned 100%
        -:  186:
        -:  187:	/* Extended entry conditon. */
       2*:  188:	OS_TRAP_IF(! v->aio_use);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  189:
        -:  190:	/* Update the write trigger. */
        2:  191:	atomic_store(&v->aio_wr_trigger, 1);
        -:  192:
        -:  193:	/* Resume the van interrupt handler. */
        2:  194:	os_sem_release(v->my_int);
call    0 returned 100%
        -:  195:
        -:  196:	/* Leave the critical section. */
        2:  197:	os_cs_leave(&v->aio_mutex);	
call    0 returned 100%
        2:  198:}
        -:  199:
        -:  200:/**
        -:  201: * van_aio_read() - this async. I/O operation triggers the py irq, to start or
        -:  202: * restart the receive procedure.
        -:  203: *
        -:  204: * @dev_id:  id of the shared memory device.
        -:  205: *
        -:  206: * Return:	None.
        -:  207: **/
function van_aio_read called 2 returned 100% blocks executed 78%
        2:  208:void van_aio_read(int dev_id)
        -:  209:{
        -:  210:	os_dev_t *v;
        -:  211:	
        -:  212:	/* Entry conditon. */
        2:  213:	v = os_van_device;
       2*:  214:	OS_TRAP_IF(v == NULL || v->id != dev_id);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  215:
        -:  216:	/* Enter the critical section. */
        2:  217:	os_cs_enter(&v->aio_mutex);
call    0 returned 100%
        -:  218:
        -:  219:	/* Extended entry conditon. */
       2*:  220:	OS_TRAP_IF(! v->aio_use);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  221:
        -:  222:	/* Update the read trigger. */
        2:  223:	atomic_store(&v->aio_rd_trigger, 1);
        -:  224:
        -:  225:	/* Resume the van interrupt handler. */
        2:  226:	os_sem_release(v->my_int);
call    0 returned 100%
        -:  227:
        -:  228:	/* Leave the critical section. */
        2:  229:	os_cs_leave(&v->aio_mutex);	
call    0 returned 100%
        2:  230:}
        -:  231:
        -:  232:/**
        -:  233: * van_read() - van waits for incoming payload.
        -:  234: *
        -:  235: * @dev_id:  id of the shared memory device.
        -:  236: * @buf:     pointer to the received payload.
        -:  237: * @count:   size of the destination buffer.
        -:  238: *
        -:  239: * Return:	number of the received bytes.
        -:  240: **/
function van_read called 2 returned 100% blocks executed 79%
        2:  241:static int van_read(int dev_id, char *buf, int count)
        -:  242:{
        -:  243:	os_shm_top_t *top;
        -:  244:	os_dev_t *v;
        -:  245:	int n;
        -:  246:
        -:  247:	/* Entry conditon. */
        2:  248:	v = os_van_device;
       2*:  249:	OS_TRAP_IF(v == NULL || v->id != dev_id || ! v->init ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
branch  8 taken 0% (fallthrough)
branch  9 taken 100%
call   10 never executed
        -:  250:		   buf == NULL || count < 1);
        -:  251:
        -:  252:	/* Get the pointer to the shm topology. */
        2:  253:	top = &v->top;
        -:  254:	
        -:  255:	/* Enter the critical section. */
        2:  256:	os_cs_enter(&v->read_mutex);
call    0 returned 100%
        -:  257:
        -:  258:	/* Define the read method. */
        2:  259:	atomic_store(&v->sync_read, 1);
        -:  260:
        -:  261:	/* Wait for the UL payload. */
        -:  262:	for(;;) {
        -:  263:		/* Get the number of the received bytes. */
        2:  264:		n = atomic_exchange(&top->ul_count, 0);
        -:  265:
        -:  266:		/* Test the number of the received bytest. */
        2:  267:		if (n < 1) { 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  268:			/* Suspend the read user. */
    #####:  269:			os_sem_wait(&v->suspend_reader);
call    0 never executed
    #####:  270:			continue;
        -:  271:		}
        -:  272:
        2:  273:		break;
        -:  274:	}
        -:  275:	
        -:  276:	/* Release the sync. read operation. */
        2:  277:	atomic_store(&v->sync_read, 0);
        -:  278:	
        -:  279:	/* Test the user buffer. */
       2*:  280:	OS_TRAP_IF(count < n);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  281:	
        -:  282:	/* Copy the received payload. */
        2:  283:	os_memcpy(buf, count, top->ul_start, n);
call    0 returned 100%
        -:  284:
        -:  285:	/* Release the pending UL buffer. */
        2:  286:	van_dlq_add(v, 0, 1);
call    0 returned 100%
        -:  287:	
        -:  288:	/* Leave the critical section. */
        2:  289:	os_cs_leave(&v->read_mutex);	
call    0 returned 100%
        -:  290:
        2:  291:	return n;
        -:  292:}
        -:  293:
        -:  294:/**
        -:  295: * van_zread() - van waits for incoming payload. With each successiv
        -:  296: *  call, the reference to the previous call is released automatically.
        -:  297: *
        -:  298: * @dev_id:  id of the shared memory device.
        -:  299: * @buf:     pointer to the received payload.
        -:  300: * @count:   size of the destination buffer.
        -:  301: *
        -:  302: * Return:	number of the received bytes.
        -:  303: **/
function van_zread called 4 returned 100% blocks executed 80%
        4:  304:static int van_zread(int dev_id, char **buf, int count)
        -:  305:{
        -:  306:	os_shm_top_t *top;
        -:  307:	os_dev_t *v;
        -:  308:	int pending_ul, n;
        -:  309:	
        -:  310:	/* Entry conditon. */
        4:  311:	v = os_van_device;
       4*:  312:	OS_TRAP_IF(v == NULL || v->id != dev_id);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  313:
        -:  314:	/* Entry condition. */
       4*:  315:	OS_TRAP_IF(! v->init);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  316:
        -:  317:	/* Get the pointer to the shm topology. */
        4:  318:	top = &v->top;
        -:  319:	
        -:  320:	/* Enter the critical section. */
        4:  321:	os_cs_enter(&v->read_mutex);
call    0 returned 100%
        -:  322:
        -:  323:	/* If the UL payload is pending, send the shm message to py. */
        4:  324:	pending_ul = atomic_exchange(&v->pending_ul, 0);
        4:  325:	if (pending_ul)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        2:  326:		van_dlq_add(v, 0, 1);
call    0 returned 100%
        -:  327:	
        -:  328:	/* Test the buffer state. */
        4:  329:	if (buf == NULL || count < 1) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  330:		/* Leave the critical section. */
        2:  331:		os_cs_leave(&v->read_mutex);	
call    0 returned 100%
        2:  332:		return 0;
        -:  333:	}
        -:  334:	
        -:  335:	/* Update the sync. read flag. */
        2:  336:	atomic_store(&v->sync_read, 1);
        -:  337:	
        -:  338:	/* Wait for the UL payload. */
        -:  339:	for(;;) {
        -:  340:		/* Get the number of the received bytes. */
        2:  341:		n = atomic_exchange(&top->ul_count, 0);
        -:  342:
        -:  343:		/* Test the number of the received bytes. */
        2:  344:		if (n < 1) { 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  345:			/* Suspend the read user. */
    #####:  346:			os_sem_wait(&v->suspend_reader);
call    0 never executed
    #####:  347:			continue;
        -:  348:		}
        -:  349:
        2:  350:		break;
        -:  351:	}
        -:  352:
        -:  353:	/* Get the pointer to the received payload. */
        2:  354:	*buf = top->ul_start;
        2:  355:	atomic_store(&v->pending_ul, 1);
        -:  356:
        -:  357:	/* Release the sync. read operation. */
        2:  358:	atomic_store(&v->sync_read, 0);
        -:  359:	
        -:  360:	/* Leave the critical section. */
        2:  361:	os_cs_leave(&v->read_mutex);	
call    0 returned 100%
        -:  362:
        2:  363:	return n;
        -:  364:}
        -:  365:
        -:  366:/**
        -:  367: * van_write() - send the DL payload to py and suspend the caller until the
        -:  368: * payload has been processed.
        -:  369: *
        -:  370: * @dev_id:  id of the shared memory device.
        -:  371: * @buf:     pointer to the payload.
        -:  372: * @count:   size of the payload.
        -:  373: *
        -:  374: * Return:	None.
        -:  375: **/
function van_write called 4 returned 100% blocks executed 81%
        4:  376:static void van_write(int dev_id, char *buf, int count)
        -:  377:{
        -:  378:	os_shm_top_t *top;
        -:  379:	os_dev_t *v;
        -:  380:
        -:  381:	/* Entry conditon. */
        4:  382:	v = os_van_device;
       4*:  383:	OS_TRAP_IF(v == NULL || v->id != dev_id || buf == NULL || count < 1);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
call    8 never executed
        -:  384:
        -:  385:	/* Entry condition. */
       4*:  386:	OS_TRAP_IF(! v->init);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  387:
        -:  388:	/* Get the pointer to the shm topology and to the van input queue. */
        4:  389:	top = &v->top;
        -:  390:	
        -:  391:	/* Enter the critical section. */
        4:  392:	os_cs_enter(&v->write_mutex);
call    0 returned 100%
        -:  393:
        -:  394:	/* XXX Test the state of the DL buffer: van->py. */
       4*:  395:	OS_TRAP_IF(top->dl_size < count || v->pending_dl);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  396:
        -:  397:	/* Change the DL state. */
        4:  398:	atomic_store(&v->pending_dl, 1);
        4:  399:	atomic_store(&v->sync_write, 1);
        -:  400:
        -:  401:	/* Fill the DL buffer. */
        4:  402:	os_memcpy(top->dl_start, OS_BUF_SIZE, buf, count);
call    0 returned 100%
        -:  403:
        -:  404:	/* Save the size of the payload. */
        4:  405:	atomic_store(&top->dl_count, count);
        -:  406:		
        -:  407:	/* Send the shm message to py. */
        4:  408:	van_dlq_add(v, count, 0);
call    0 returned 100%
        -:  409:
        -:  410:	/* Suspend the caller until the action is executed. */
        4:  411:	os_sem_wait(&v->suspend_writer);
call    0 returned 100%
        -:  412:
        -:  413:	/* Leave the critical section. */
        4:  414:	os_cs_leave(&v->write_mutex);	
call    0 returned 100%
        4:  415:}
        -:  416:
        -:  417:#if defined(OS_CLOSE_NET)
        -:  418:/**
        -:  419: * van_exit_exec() - the van_int thread shall not be suspended with named
        -:  420: * van_int semphore.
        -:  421: *
        -:  422: * @msg:  generic input message.
        -:  423: *
        -:  424: * Return:	None.
        -:  425: **/
        -:  426:static void van_exit_exec(os_queue_elem_t *msg)
        -:  427:{
        -:  428:	OS_TRACE(("%s [s:ready, m:van-exit] -> [s:ready]\n", VP));
        -:  429:}
        -:  430:#endif
        -:  431:
        -:  432:/**
        -:  433: * van_close() - the van process shall call this function to remove the
        -:  434: * shared memory ressources.
        -:  435: *
        -:  436: * @dev_id:  id of the van shm device.
        -:  437: *
        -:  438: * Return:	None.
        -:  439: **/
function van_close called 2 returned 100% blocks executed 76%
        2:  440:static void van_close(int dev_id)
        -:  441:{
        -:  442:#if defined(OS_CLOSE_NET)
        -:  443:	os_queue_elem_t msg;
        -:  444:#endif
        -:  445:	os_dev_t *v;
        -:  446:	int rv;
        -:  447:
        -:  448:	/* Entry conditon. */
        2:  449:	v = os_van_device;
       2*:  450:	OS_TRAP_IF(v == NULL || v->id != dev_id);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  451:	
        -:  452:	/* Change the state of the shm area. */
        2:  453:	v->init = 0;
        -:  454:
        -:  455:#if defined(OS_CLOSE_NET)
        -:  456:	/* Define the van_int terminate message. */
        -:  457:	os_memset(&msg, 0, sizeof(msg));
        -:  458:	msg.param = v->thread;
        -:  459:	msg.cb    = van_exit_exec;	
        -:  460:	OS_SEND(v->thread, &msg, sizeof(msg));
        -:  461:#endif
        -:  462:	/* Resume the van_int thread, to terminate it. */
        2:  463:	atomic_store(&v->down, 1);
        2:  464:	os_sem_release(v->my_int);
call    0 returned 100%
        -:  465:	
        -:  466:	/* Delete the van interrupt handler. */
        2:  467:	os_thread_destroy(v->thread);
call    0 returned 100%
        -:  468:	
        -:  469:	/* Delete the access and the mapping to the shared memory. */
        2:  470:	os_shm_close(v);
call    0 returned 100%
        -:  471:	
        -:  472:	/* Delete the named van semaphore. */
        2:  473:	rv = sem_unlink(v->my_int_name);
call    0 returned 100%
       2*:  474:	OS_TRAP_IF(rv != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  475:	
        -:  476:	/* Delete the named python semaphore. */
        2:  477:	rv = sem_unlink(v->other_int_name);
call    0 returned 100%
       2*:  478:	OS_TRAP_IF(rv != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  479:
        -:  480:	/* Remove the shared memory file. */
        2:  481:	rv = remove(OS_SHM_FILE);
call    0 returned 100%
       2*:  482:	OS_TRAP_IF(rv != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  483:	
        -:  484:	/* Free the van shm device. */
        2:  485:	OS_FREE(os_van_device);
call    0 returned 100%
        2:  486:}
        -:  487:
        -:  488:/**
        -:  489: * van_int_write() - resume the suspend caller in van_write or request DL data
        -:  490: * from the aio user.
        -:  491: *
        -:  492: * @v:  pointer to the van device state.
        -:  493: * @t:  pointer to the shared memory topology.
        -:  494: *
        -:  495: * Return:	None.
        -:  496: **/
function van_int_write called 10 returned 100% blocks executed 91%
       10:  497:static void van_int_write(os_dev_t *v, os_shm_top_t *t)
        -:  498:{
        -:  499:	int aio_use, sync, pending_dl, count;
        -:  500:	
        -:  501:	/* Test the aio status request. */
       10:  502:	aio_use = atomic_load(&v->aio_use);
       10:  503:	if (! aio_use) {
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
        -:  504:		/* Test the write method. */
        4:  505:		sync = atomic_exchange(&v->sync_write, 0);
        4:  506:		if (sync)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4:  507:			os_sem_release(&v->suspend_writer);
call    0 returned 100%
        -:  508:		
        4:  509:		return;
        -:  510:	}
        -:  511:
        -:  512:	/* Reset the write trigger. */
        6:  513:	atomic_store(&v->aio_wr_trigger, 0);
        -:  514:
        -:  515:	/* Test the release status of the DL buffer, which py has not
        -:  516:	 * consumed. */
        6:  517:	pending_dl = atomic_load(&v->pending_dl);
        6:  518:	if (pending_dl)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  519:		return;
        -:  520:	
        -:  521:	/* Request DL data from the aio user. */
        6:  522:	count = v->aio_cb.write_cb(v->id, t->dl_start, OS_BUF_SIZE);
call    0 returned 100%
        6:  523:	if (count < 1)
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        2:  524:		return;
        -:  525:
        -:  526:	/* Change the DL state. */
        4:  527:	atomic_store(&v->pending_dl, 1);
        -:  528:					
        -:  529:	/* Save the size of the payload. */
        4:  530:	atomic_store(&t->dl_count, count);
        -:  531:
        -:  532:	/* Send the shm message to py. */
        4:  533:	van_aio_dlq_add(v, count, 0);
call    0 returned 100%
        -:  534:}
        -:  535:
        -:  536:/**
        -:  537: * van_int_read() - pass the UL data to the async. caller or resume the
        -:  538: * suspended caller in read or zread.
        -:  539: *
        -:  540: * @v:      pointer to the van device state.
        -:  541: * @t:      pointer to the shared memory topology.
        -:  542: * @count:  number of the pending DL characters.
        -:  543: *
        -:  544: * Return:	None.
        -:  545: **/
function van_int_read called 10 returned 100% blocks executed 75%
       10:  546:static void van_int_read(os_dev_t *v, os_shm_top_t *t, int count)
        -:  547:{
        -:  548:	int aio_use, sync, consumed;
        -:  549:	
        -:  550:	/* Test the aio status. */
       10:  551:	aio_use = atomic_load(&v->aio_use);
       10:  552:	if (aio_use) {
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
        -:  553:		/* Reset the read trigger. */
        6:  554:		atomic_store(&v->aio_rd_trigger, 0);
        -:  555:
        -:  556:		/* Test the number of the pending UL characters. */
        6:  557:		if (count < 1)
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        2:  558:			return;
        -:  559:		
        -:  560:		/* Pass the UL data to the aio user. */
        4:  561:		consumed = v->aio_cb.read_cb(v->id, t->ul_start, count);
call    0 returned 100%
        -:  562:
        -:  563:		/* Update the DL state. */
       4*:  564:		OS_TRAP_IF(consumed > count || consumed < 0);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        4:  565:		if (consumed != count) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  566:			atomic_store(&t->ul_count, count - consumed);
    #####:  567:			return;
        -:  568:		}
        -:  569:
        -:  570:		/* Reset the UL state. */
        4:  571:		atomic_store(&t->ul_count, 0);
        -:  572:		
        -:  573:		/* Release the pending UL buffer. */
        4:  574:		van_aio_dlq_add(v, 0, 1);
call    0 returned 100%
        -:  575:	}
        -:  576:	else {
        -:  577:		/* Save the number of the received UL bytes. */
        4:  578:		atomic_store(&t->ul_count, count);
        -:  579:			
        -:  580:		/* Test the read method. */
        4:  581:		sync = atomic_exchange(&v->sync_read, 0);
        -:  582:
       4*:  583:		OS_TRACE(("%s dl_count=%d, read=%d\n", VP, t->ul_count, sync));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  584:
        4:  585:		if (sync)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  586:			os_sem_release(&v->suspend_reader);
call    0 never executed
        -:  587:	}
        -:  588:}
        -:  589:
        -:  590:/**
        -:  591: * van_int_exec() - the van_int thread waits for the van_int triggered by py
        -:  592: * or internally to process a send order.
        -:  593: *
        -:  594: * @msg:  generic input message.
        -:  595: *
        -:  596: * Return:	None.
        -:  597: **/
function van_int_exec called 2 returned 100% blocks executed 89%
        2:  598:static void van_int_exec(os_queue_elem_t *msg)
        -:  599:{
        -:  600:	os_shm_queue_t *q;
        -:  601:	os_shm_msg_t *shm_m;
        -:  602:	os_shm_top_t *t;
        -:  603:	os_dev_t *v;
        -:  604:	int down;
        -:  605:
        -:  606:	/* Get the address of the van shared memory state. */
        2:  607:	v = os_van_device;
        -:  608:
        -:  609:	/* Get the pointer of the van shm input queue. */
        2:  610:	t = &v->top;
        2:  611:	q = v->top.ul_queue;
        -:  612:
        -:  613:	/* Loop thru the van interrupts triggered by py. */
        -:  614:	for(;;) {
        -:  615:		/* Test the access method to the van device. */
       22:  616:		if (v->aio_use) {
branch  0 taken 55% (fallthrough)
branch  1 taken 45%
        -:  617:			/* Test the UL payload state from py and trigger the
        -:  618:			 *  user actions. */
       12:  619:			if (v->aio_rd_trigger)
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        2:  620:				van_int_read(v, t, t->ul_count);
call    0 returned 100%
        -:  621:			
        -:  622:			/* Test the aio status, request data from the user and
        -:  623:			 *  inform py. */
       12:  624:			if (v->aio_wr_trigger)
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        2:  625:				van_int_write(v, t);
call    0 returned 100%
        -:  626:		}		
        -:  627:
      22*:  628:		OS_TRACE(("%s [s:ready, m:van-int] -> [s:suspended]\n", VP));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  629:
        -:  630:		/* Wait for the van_int trigger. */
       22:  631:		os_sem_wait(v->my_int);
call    0 returned 100%
        -:  632:
        -:  633:		/* Test the thread state. */
       22:  634:		down = atomic_load(&v->down);
       22:  635:		if (down) {
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
       2*:  636:			OS_TRACE(("%s [s:suspended, m:van-int] -> [s:down]\n", VP));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        2:  637:			return;
        -:  638:		} else {
      20*:  639:			OS_TRACE(("%s [s:suspended, m:van-int] -> [s:ready]\n", VP));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  640:		}
        -:  641:	
        -:  642:		/* Analyze the van shm input queue. */
       36:  643:		while (q->tail != q->head) {
branch  0 taken 44%
branch  1 taken 56% (fallthrough)
       16:  644:			shm_m = &q->ring[q->tail];
        -:  645:
        -:  646:			/* Test the UL payload state from van. */
       16:  647:			if (shm_m->size > 0) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  648:				/* Test the UL payload state from py and trigger the user actions. */
        8:  649:				van_int_read(v, t, shm_m->size);
call    0 returned 100%
        -:  650:			}
        -:  651:
        -:  652:			/* Test the state of the sent DL playload from van to py. */
       16:  653:			if (shm_m->consumed) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  654:				/* Release the DL transfer. */
        8:  655:				atomic_store(&v->pending_dl, 0);
        -:  656:
        -:  657:				/* Trigger the van user DL actions. */
        8:  658:				van_int_write(v, t);
call    0 returned 100%
        -:  659:			}
        -:  660:		
        -:  661:			/* Increment and test the start of the message list. */
       16:  662:			q->tail++;
       16:  663:			if (q->tail >= OS_SHM_Q_SIZE)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        4:  664:				q->tail = 0;
        -:  665:		}
        -:  666:	}
        -:  667:}
        -:  668:
        -:  669:/**
        -:  670: * van_file_create() - create the shared memory file.
        -:  671: *
        -:  672: * Return:	None.
        -:  673: **/
function van_file_create called 2 returned 100% blocks executed 69%
        2:  674:static void van_file_create(void)
        -:  675:{
        -:  676:	int oflag, fd, rv;
        -:  677:	mode_t mode;
        -:  678:	
        -:  679:	/* Control flags for the open call. */
        2:  680:	oflag = O_RDWR | O_CREAT | O_EXCL;
        2:  681:	mode =  S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
        -:  682:
        2:  683:	fd = open(OS_SHM_FILE, oflag, mode);
call    0 returned 100%
       2*:  684:	OS_TRAP_IF(fd == -1);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  685:
        -:  686:	/* Stretch the file size. */
        2:  687:	rv = lseek(fd, OS_SHM_SIZE - 1, SEEK_SET);
call    0 returned 100%
       2*:  688:	OS_TRAP_IF(rv == -1);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  689:
        -:  690:	/* Write just one byte at the end and close the file. */
        2:  691:	rv = write(fd, "", 1);
call    0 returned 100%
       2*:  692:	OS_TRAP_IF(rv == -1);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  693:
        2:  694:	rv = close(fd);
call    0 returned 100%
       2*:  695:	OS_TRAP_IF(rv != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        2:  696:}
        -:  697:	
        -:  698:/**
        -:  699: * van_open() - the van process shall call this function to create the shared
        -:  700: * memory device.
        -:  701: *
        -:  702: * @name:  pointer to the van device name.
        -:  703: *
        -:  704: * Return:	the device id.
        -:  705: **/
function van_open called 2 returned 100% blocks executed 85%
        2:  706:static int van_open(char *name)
        -:  707:{
        -:  708:	os_queue_elem_t msg;
        -:  709:	os_dev_t *v;
        -:  710:	mode_t mode;
        -:  711:	int oflag;
        -:  712:	
        -:  713:	/* Entry condition. */
       2*:  714:	OS_TRAP_IF(name == NULL || os_strcmp(name, OS_VAN_NAME) != 0);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
call    5 never executed
        -:  715:
        -:  716:	/* Allocate the van device state. */
        2:  717:	v = os_van_device = OS_MALLOC(sizeof(os_dev_t));
call    0 returned 100%
        2:  718:	os_memset(v, 0, sizeof(os_dev_t));
call    0 returned 100%
        -:  719:
        -:  720:	/* Save the device identificaton. */
        2:  721:	v->id = OS_DEV_VAN;
        2:  722:	v->name = OS_VAN_NAME;
        2:  723:	v->file_name = OS_SHM_FILE;
        -:  724:	
        -:  725:	/* Save the interrupt names. */
        2:  726:	v->my_int_name    = OS_VAN_INT;
        2:  727:	v->other_int_name = OS_PY_INT;
        -:  728:
        -:  729:	/* Control flags for the sem_open call. */
        2:  730:	oflag = O_CREAT | O_EXCL;
        2:  731:	mode =  S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
        -:  732:
        -:  733:	/* Create the named van semaphore. */
        2:  734:	v->my_int = sem_open(OS_VAN_INT, oflag, mode, 0);
call    0 returned 100%
       2*:  735:	OS_TRAP_IF(v->my_int == SEM_FAILED);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  736:
        -:  737:	/* Create the named python semaphore. */
        2:  738:	v->other_int = sem_open(OS_PY_INT, oflag, mode, 0);
call    0 returned 100%
       2*:  739:	OS_TRAP_IF(v->other_int == SEM_FAILED);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  740:
        -:  741:	/* Create the shared memory file. */
        2:  742:	van_file_create();
call    0 returned 100%
        -:  743:	
        -:  744:	/* Map the file into shared memory. */
        2:  745:	os_shm_open(v);
call    0 returned 100%
        -:  746:
        -:  747:	/* Initialize the shm area. */
        2:  748:	os_memset(v->start, 0, v->size);
call    0 returned 100%
        -:  749:
        -:  750:	/* Install the van interrupt handler/thread. */
        2:  751:	v->thread = os_thread_create("van_int", PRIO, Q_SIZE);
call    0 returned 100%
        -:  752:	
        -:  753:	/* Change the state of the shm area. */
        2:  754:	v->init = 1;
        -:  755:
        -:  756:	/* Start with processing of the van_int. */
        2:  757:	os_memset(&msg, 0, sizeof(msg));
call    0 returned 100%
        2:  758:	msg.param = v->thread;
        2:  759:	msg.cb    = van_int_exec;
        2:  760:	OS_SEND(v->thread, &msg, sizeof(msg));
call    0 returned 100%
        -:  761:	
        2:  762:	return OS_DEV_VAN;
        -:  763:}
        -:  764:
        -:  765:/*============================================================================
        -:  766:  EXPORTED FUNCTIONS
        -:  767:  ============================================================================*/
        -:  768:/**
        -:  769: * os_van_ripcord() - release critical van device resources.
        -:  770: *
        -:  771: * @coverage:  if 0, release critical device resoures.
        -:  772: *
        -:  773: * Return:	None.
        -:  774: **/
function os_van_ripcord called 2 returned 100% blocks executed 19%
        2:  775:void os_van_ripcord(int coverage)
        -:  776:{
        -:  777:	os_dev_t *v;
        -:  778:
        -:  779:	/* Entry conditon. */
        2:  780:	v = os_van_device;
        -:  781:
        -:  782:	/* Test the van device state. */
       2*:  783:	if (v == NULL || coverage)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        2:  784:		return;
        -:  785:
        -:  786:	/* Remove the reference to the van semaphore. */
    #####:  787:	if (v->my_int) {
branch  0 never executed
branch  1 never executed
    #####:  788:		sem_close(v->my_int);
call    0 never executed
    #####:  789:		sem_unlink(v->my_int_name);
call    0 never executed
        -:  790:	}
        -:  791:	
        -:  792:	/* Remove the reference to the python semaphore. */
    #####:  793:	if (v->other_int) {
branch  0 never executed
branch  1 never executed
    #####:  794:		sem_close(v->other_int);
call    0 never executed
    #####:  795:		sem_unlink(v->other_int_name);
call    0 never executed
        -:  796:	}
        -:  797:
        -:  798:	/* Test the file descriptor of the shared memory file. */
    #####:  799:	if (v->fd == 0)
branch  0 never executed
branch  1 never executed
    #####:  800:		return;
        -:  801:
        -:  802:	/* Delete the mapping of the shared memory area. */
    #####:  803:	if (v->start != 0)
branch  0 never executed
branch  1 never executed
    #####:  804:		munmap(v->start, v->size);
call    0 never executed
        -:  805:
        -:  806:	/* Close and remove the shared memory file. */
    #####:  807:	close(v->fd);
call    0 never executed
    #####:  808:	remove(OS_SHM_FILE);
call    0 never executed
        -:  809:}
        -:  810:
        -:  811:/**
        -:  812: * os_van_exit() - test the state of the shared memory devices.
        -:  813: *
        -:  814: * Return:	None.
        -:  815: **/
function os_van_exit called 2 returned 100% blocks executed 67%
        2:  816:void os_van_exit(void)
        -:  817:{
       2*:  818:	OS_TRAP_IF(os_van_device != NULL);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        2:  819:}
        -:  820:
        -:  821:/**
        -:  822: * os_van_init() - request the entry points for the van shared memory device.
        -:  823: *
        -:  824: * @conf:  pointer to the trace configuration.
        -:  825: * @op:    pointer to the entry points of the shm device.
        -:  826: *
        -:  827: * Return:	None.
        -:  828: **/
function os_van_init called 2 returned 100% blocks executed 100%
        2:  829:void os_van_init(os_conf_t *conf, os_dev_ops_t *op)
        -:  830:{
        -:  831:	/* Save the reference to the OS configuration. */
        2:  832:	os_conf_p = conf;
        -:  833:
        -:  834:	/* Save the van shared memory operations. */
        2:  835:	op->device_name = OS_VAN_NAME;
        2:  836:	op->device_id   = OS_DEV_VAN;
        2:  837:	op->open        = van_open;
        2:  838:	op->close       = van_close;
        2:  839:	op->write       = van_write;
        2:  840:	op->zread       = van_zread;
        2:  841:	op->read        = van_read;
        2:  842:	op->aio_action  = van_aio_action;
        2:  843:	op->aio_write   = van_aio_write;
        2:  844:	op->aio_read    = van_aio_read;
        2:  845:}
