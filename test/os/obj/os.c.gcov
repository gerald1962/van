        -:    0:Source:/home/gerald/van_development/van/os/os.c
        -:    1:// SPDX-License-Identifier: GPL-2.0
        -:    2:
        -:    3:/*
        -:    4: * Operating system interfaces.
        -:    5: *
        -:    6: * Copyright (C) 2021 Gerald Schueller <gerald.schueller@web.de>
        -:    7: */
        -:    8:
        -:    9:/*============================================================================
        -:   10:  IMPORTED INCLUDE REFERENCES
        -:   11:  ============================================================================*/
        -:   12:#include <pthread.h>     /* POSIX thread. */
        -:   13:
        -:   14:/*============================================================================
        -:   15:  EXPORTED INCLUDE REFERENCES
        -:   16:  ============================================================================*/
        -:   17:#include "os.h"          /* Operating system: os_sem_init() */
        -:   18:#include "os_private.h"  /* Local interfaces of the OS: os_trap_init() */
        -:   19:
        -:   20:/*============================================================================
        -:   21:  LOCAL NAME CONSTANTS DEFINITIONS
        -:   22:  ============================================================================*/
        -:   23:/*============================================================================
        -:   24:  MACROS
        -:   25:  ============================================================================*/
        -:   26:/*============================================================================
        -:   27:  LOCAL TYPE DEFINITIONS
        -:   28:  ============================================================================*/
        -:   29:/*============================================================================
        -:   30:  LOCAL DATA
        -:   31:  ============================================================================*/
        -:   32:
        -:   33:/* OS configuration. */
        -:   34:static os_conf_t os_conf;
        -:   35:
        -:   36:/**
        -:   37: * os_stat - overall state of the OS.
        -:   38: *
        -:   39: * @is_init:     1, if the OS has been initialized.
        -:   40: * @cs_count:    number of created mutexes.
        -:   41: * @sem_count:   number of created semaphores.
        -:   42: * @spin_count:  number of created spin locks.
        -:   43: **/
        -:   44:static struct os_stat_s {
        -:   45:	atomic_int is_init;
        -:   46:	atomic_int cs_count;
        -:   47:	atomic_int sem_count;
        -:   48:	atomic_int spin_count;
        -:   49:} os_stat;
        -:   50:
        -:   51:/*============================================================================
        -:   52:  LOCAL FUNCTION PROTOTYPES
        -:   53:  ============================================================================*/
        -:   54:/*============================================================================
        -:   55:  LOCAL FUNCTIONS
        -:   56:  ============================================================================*/
        -:   57:/*============================================================================
        -:   58:  EXPORTED FUNCTIONS
        -:   59:  ============================================================================*/
        -:   60:
        -:   61:/**
        -:   62: * os_cs_init() - initialize the mutex.
        -:   63: *
        -:   64: * @mutex:  address of the mutex.
        -:   65: *
        -:   66: * Return:	None.
        -:   67: **/
function os_cs_init called 58 returned 100% blocks executed 67%
       58:   68:void os_cs_init(pthread_mutex_t *mutex)
        -:   69:{
        -:   70:	pthread_mutexattr_t attr;
        -:   71:	int ret;
        -:   72:	
        -:   73:	/* Entry condition. */
      58*:   74:	OS_TRAP_IF(mutex == NULL);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   75:	
       58:   76:	ret = pthread_mutexattr_init(&attr);
call    0 returned 100%
      58*:   77:	OS_TRAP_IF(ret != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   78:	
       58:   79:	ret = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
call    0 returned 100%
      58*:   80:	OS_TRAP_IF(ret != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   81:	
       58:   82:	ret = pthread_mutex_init(mutex, &attr);
call    0 returned 100%
      58*:   83:	OS_TRAP_IF(ret != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   84:	
       58:   85:	ret = pthread_mutexattr_destroy(&attr);
call    0 returned 100%
      58*:   86:	OS_TRAP_IF(ret != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   87:
       58:   88:	atomic_fetch_add(&os_stat.cs_count, 1);
       58:   89:}
        -:   90:
        -:   91:/**
        -:   92: * os_cs_enter() - enter the critical section.
        -:   93: *
        -:   94: * @mutex:  address of the mutex.
        -:   95: *
        -:   96: * Return:	None.
        -:   97: **/
function os_cs_enter called 15507 returned 102% blocks executed 67%
    15507:   98:void os_cs_enter(pthread_mutex_t *mutex)
        -:   99:{
        -:  100:	int ret;
        -:  101:	
        -:  102:	/* Entry condition. */
   15507*:  103:	OS_TRAP_IF(mutex == NULL);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  104:	
    15507:  105:	ret = pthread_mutex_lock(mutex);
call    0 returned 102%
        -:  106:	
        -:  107:	/* Final condition. */
   15789*:  108:	OS_TRAP_IF(ret != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    15789:  109:}
        -:  110:
        -:  111:/**
        -:  112: * os_cs_leave() - leave the critical section.
        -:  113: *
        -:  114: * @mutex:  address of the mutex.
        -:  115: *
        -:  116: * Return:	None.
        -:  117: **/
function os_cs_leave called 15718 returned 101% blocks executed 67%
    15718:  118:void os_cs_leave(pthread_mutex_t *mutex)
        -:  119:{
        -:  120:	int ret;
        -:  121:	
        -:  122:	/* Entry condition. */
   15718*:  123:	OS_TRAP_IF(mutex == NULL);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  124:	
    15718:  125:	ret = pthread_mutex_unlock(mutex);
call    0 returned 101%
        -:  126:	
        -:  127:	/* Final condition. */
   15815*:  128:	OS_TRAP_IF(ret != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
    15815:  129:}
        -:  130:
        -:  131:/**
        -:  132: * os_cs_destroy() - delete the mutex.
        -:  133: *
        -:  134: * @mutex:  address of the mutex.
        -:  135: *
        -:  136: * Return:	None.
        -:  137: **/
function os_cs_destroy called 58 returned 100% blocks executed 67%
       58:  138:void os_cs_destroy(pthread_mutex_t *mutex)
        -:  139:{
        -:  140:	int ret;
        -:  141:	
        -:  142:	/* Entry condition. */
      58*:  143:	OS_TRAP_IF(mutex == NULL);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  144:	
       58:  145:	ret = pthread_mutex_destroy(mutex);
call    0 returned 100%
        -:  146:	
        -:  147:	/* Final condition. */
      58*:  148:	OS_TRAP_IF(ret != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  149:	
       58:  150:	atomic_fetch_sub(&os_stat.cs_count, 1);
       58:  151:}
        -:  152:
        -:  153:/**
        -:  154: * os_sem_init() - initialize the semaphore.
        -:  155: *
        -:  156: * @sem:         address of the semaphore.
        -:  157: * @init_value:  inital value of the semaphore counter.
        -:  158: *
        -:  159: * Return:	None.
        -:  160: **/
function os_sem_init called 232 returned 100% blocks executed 67%
      232:  161:void os_sem_init(sem_t *sem, unsigned int init_value)
        -:  162:{
        -:  163:	int ret;
        -:  164:	
        -:  165:	/* Entry condition. */
     232*:  166:	OS_TRAP_IF(sem == NULL);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  167:
      232:  168:	ret = sem_init(sem, 0, init_value);
call    0 returned 100%
        -:  169:
        -:  170:	/* Final condition. */
     232*:  171:	OS_TRAP_IF(ret != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  172:
      232:  173:	atomic_fetch_add(&os_stat.sem_count, 1);	
      232:  174:}
        -:  175:
        -:  176:/**
        -:  177: * os_sem_wait() - suspend the current thread.
        -:  178: *
        -:  179: * @sem:         address of the semaphore.
        -:  180: *
        -:  181: * Return:	None.
        -:  182: **/
function os_sem_wait called 1235 returned 100% blocks executed 67%
     1235:  183:void os_sem_wait(sem_t *sem)
        -:  184:{
        -:  185:	int ret;
        -:  186:	
        -:  187:	/* Entry condition. */
    1235*:  188:	OS_TRAP_IF(sem == NULL);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  189:
     1235:  190:	ret = sem_wait(sem);
call    0 returned 100%
        -:  191:
        -:  192:	/* Final condition. */
    1232*:  193:	OS_TRAP_IF(ret != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     1232:  194:}
        -:  195:
        -:  196:/**
        -:  197: * os_sem_release() - release the current thread.
        -:  198: *
        -:  199: * @sem:         address of the semaphore.
        -:  200: *
        -:  201: * Return:	None.
        -:  202: **/
function os_sem_release called 1751 returned 100% blocks executed 67%
     1751:  203:void os_sem_release(sem_t *sem)
        -:  204:{
        -:  205:	int ret;
        -:  206:	
        -:  207:	/* Entry condition. */
    1751*:  208:	OS_TRAP_IF(sem == NULL);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  209:
     1751:  210:	ret = sem_post(sem);
call    0 returned 100%
        -:  211:
        -:  212:	/* Final condition. */
    1755*:  213:	OS_TRAP_IF(ret != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     1755:  214:}
        -:  215:
        -:  216:/**
        -:  217: * os_sem_delete() - destroy the semaphore.
        -:  218: *
        -:  219: * @sem:         address of the semaphore.
        -:  220: *
        -:  221: * Return:	None.
        -:  222: **/
function os_sem_delete called 232 returned 100% blocks executed 67%
      232:  223:void os_sem_delete(sem_t *sem)
        -:  224:{
        -:  225:	int ret;
        -:  226:	
        -:  227:	/* Entry condition. */
     232*:  228:	OS_TRAP_IF (sem == NULL);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  229:
      232:  230:	ret = sem_destroy (sem);
call    0 returned 100%
        -:  231:
        -:  232:	/* Final condition. */
     232*:  233:	OS_TRAP_IF (ret != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  234:	
      232:  235:	atomic_fetch_sub(&os_stat.sem_count, 1);	
      232:  236:}
        -:  237:
        -:  238:
        -:  239:/**
        -:  240: * os_spin_init() - initialize the spinlock.
        -:  241: *
        -:  242: * @sem:         address of the spinlock.
        -:  243: *
        -:  244: * Return:	None.
        -:  245: **/
function os_spin_init called 96 returned 100% blocks executed 67%
       96:  246:void os_spin_init(spinlock_t *spinlock)
        -:  247:{
        -:  248:	int ret;
        -:  249:	
        -:  250:	/* Entry condition. */
      96*:  251:	OS_TRAP_IF(spinlock == NULL);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  252:
        -:  253:#if defined(USE_PTHREAD_SPIN)
        -:  254:	ret = pthread_spin_init(spinlock, PTHREAD_PROCESS_SHARED);
        -:  255:#else
       96:  256:	ret = pthread_mutex_init(spinlock, NULL);
call    0 returned 100%
        -:  257:#endif
        -:  258:	/* Final condition. */
      96*:  259:	OS_TRAP_IF(ret != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  260:	
       96:  261:	atomic_fetch_add(&os_stat.spin_count, 1);
       96:  262:}
        -:  263:
        -:  264:/**
        -:  265: * os_spin_lock() - aquire an atomic lock.
        -:  266: *
        -:  267: * @sem:         address of the spinlock.
        -:  268: *
        -:  269: * Return:	None.
        -:  270: **/
function os_spin_lock called 1987 returned 102% blocks executed 67%
     1987:  271:void os_spin_lock(spinlock_t *spinlock)
        -:  272:{
        -:  273:	int ret;
        -:  274:	
        -:  275:	/* Entry condition. */
    1987*:  276:	OS_TRAP_IF(spinlock == NULL);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  277:
        -:  278:#if defined(USE_PTHREAD_SPIN)
        -:  279:	ret = pthread_spin_lock(spinlock);
        -:  280:#else
     1987:  281:	ret = pthread_mutex_lock(spinlock);
call    0 returned 102%
        -:  282:#endif
        -:  283:	/* Final condition. */
    2026*:  284:	OS_TRAP_IF(ret != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     2026:  285:}
        -:  286:
        -:  287:/**
        -:  288: * os_spin_unlock() - unlock the spinlock.
        -:  289: *
        -:  290: * @sem:         address of the spinlock.
        -:  291: *
        -:  292: * Return:	None.
        -:  293: **/
function os_spin_unlock called 2026 returned 99% blocks executed 67%
     2026:  294:void os_spin_unlock(spinlock_t *spinlock)
        -:  295:{
        -:  296:	int ret;
        -:  297:	
        -:  298:	/* Entry condition. */
    2026*:  299:	OS_TRAP_IF(spinlock == NULL);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  300:	
        -:  301:#if defined(USE_PTHREAD_SPIN)
        -:  302:	ret = pthread_spin_unlock(spinlock);
        -:  303:#else
     2026:  304:	ret = pthread_mutex_unlock(spinlock);
call    0 returned 99%
        -:  305:#endif
        -:  306:	/* Final condition. */
    2002*:  307:	OS_TRAP_IF(ret != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
     2002:  308:}
        -:  309:
        -:  310:/**
        -:  311: * os_spin_destroy() - destroy the spinlock.
        -:  312: *
        -:  313: * @sem:         address of the spinlock.
        -:  314: *
        -:  315: * Return:	None.
        -:  316: **/
function os_spin_destroy called 96 returned 100% blocks executed 67%
       96:  317:void os_spin_destroy(spinlock_t *spinlock)
        -:  318:{
        -:  319:	int ret;
        -:  320:	
        -:  321:	/* Entry condition. */
      96*:  322:	OS_TRAP_IF(spinlock == NULL);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  323:	
        -:  324:#if defined(USE_PTHREAD_SPIN)
        -:  325:	ret = pthread_spin_destroy(spinlock);
        -:  326:#else
       96:  327:	ret = pthread_mutex_destroy(spinlock);
call    0 returned 100%
        -:  328:#endif
        -:  329:	/* Final condition. */
      96*:  330:	OS_TRAP_IF(ret != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  331:	
       96:  332:	atomic_fetch_sub(&os_stat.spin_count, 1);
       96:  333:}
        -:  334:
        -:  335:/**
        -:  336: * os_statistics() - provide data on the OS state.
        -:  337: *
        -:  338: * @stat:  address of the status information.
        -:  339: *
        -:  340: * Return:	None.
        -:  341: **/
function os_statistics called 38 returned 100% blocks executed 71%
       38:  342:void os_statistics(os_statistics_t *stat)
        -:  343:{
        -:  344:	int is_init;
        -:  345:	
        -:  346:	/* Test the OS state. */
       38:  347:	is_init = atomic_load(&os_stat.is_init);
      38*:  348:	OS_TRAP_IF(! is_init);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  349:	
        -:  350:	/* Entry condition. */
      38*:  351:	OS_TRAP_IF(stat == NULL);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  352:	
        -:  353:	/* Get information about the thread state. */
       38:  354:	os_thread_statistics(stat);
call    0 returned 100%
        -:  355:	
        -:  356:	/* Get information about the memory state. */
       38:  357:	os_mem_statistics(stat);
call    0 returned 100%
        -:  358:
        -:  359:	/* Complete the data gathering. */
       38:  360:	stat->cs_count   = os_stat.cs_count;
       38:  361:	stat->sem_count  = os_stat.sem_count;
       38:  362:	stat->spin_count = os_stat.spin_count;
       38:  363:}
        -:  364:
        -:  365:/**
        -:  366: * os_trace_button() - change the trace configuration.
        -:  367: *
        -:  368: * @n:  if n eq. 0, trace off, else trace on.
        -:  369: *
        -:  370: * Return:	None.
        -:  371: **/
function os_trace_button called 2 returned 100% blocks executed 100%
        2:  372:void os_trace_button(int n)
        -:  373:{
        2:  374:	os_conf.trace_stat = n;
        2:  375:}
        -:  376:
        -:  377:/**
        -:  378: * os_init() - ensure the one time call and propagate the trace interface to the
        -:  379: * submodules.
        -:  380: *
        -:  381: * @creator:  if 1, create the shared memory resources.
        -:  382: *
        -:  383: * Return:	None.
        -:  384: **/
function os_init called 2 returned 100% blocks executed 88%
        2:  385:void os_init(int creator)
        -:  386:{
        -:  387:	int is_init;
        -:  388:	
        -:  389:	/* Test the OS state. */
        2:  390:	is_init = atomic_load(&os_stat.is_init);
        2:  391:	atomic_store(&os_stat.is_init, 1);
       2*:  392:	OS_TRAP_IF(is_init);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  393:
        -:  394:	/* Switch on the trace. */
        2:  395:	os_conf.trace_stat = 1;
        -:  396:	
        -:  397:	/* Install a signal handler to generate a core dump, if the test
        -:  398:         * programm has been terminated with Ctrl-C. */
        2:  399:        os_trap_init(&os_conf);
call    0 returned 100%
        -:  400:
        -:  401:	/* Initialize the os_malloc list. */
        2:  402:	os_mem_init();
call    0 returned 100%
        -:  403:	
        -:  404:	/* Initialize the thread table. */
        2:  405:	os_thread_init(&os_conf);
call    0 returned 100%
        -:  406:	
        -:  407:	/* Install the shared memory area. */
        2:  408:	os_cab_init(&os_conf, creator);
call    0 returned 100%
        -:  409:
        -:  410:	/* Initialize the OS timer list. */
        2:  411:	os_clock_init_();
call    0 returned 100%
        2:  412:}
        -:  413:
        -:  414:/**
        -:  415: * os_exit() - ensure the one the one time call and test pending resources.
        -:  416: *
        -:  417: * Return:	None.
        -:  418: **/
function os_exit called 2 returned 100% blocks executed 82%
        2:  419:void os_exit(void)
        -:  420:{
        -:  421:	struct os_stat_s *p;
        -:  422:	int is_init;
        -:  423:
        -:  424:	/* Test the OS state. */
        2:  425:	p = &os_stat;	
        2:  426:	is_init = atomic_load(&p->is_init);
       2*:  427:	OS_TRAP_IF(! is_init);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  428:
        2:  429:	os_cab_exit();
call    0 returned 100%
        2:  430:	os_thread_exit();
call    0 returned 100%
        2:  431:	os_mem_exit();
call    0 returned 100%
        2:  432:	os_clock_exit_();
call    0 returned 100%
        -:  433:
        -:  434:	/* Test the OS state. */
       2*:  435:	OS_TRAP_IF(p->cs_count != 0 || p->sem_count != 0 ||  p->spin_count != 0);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
call    6 never executed
        -:  436:
        -:  437:	/* Change the OS state. */
        2:  438:	atomic_store(&p->is_init, 0);
        2:  439:}
