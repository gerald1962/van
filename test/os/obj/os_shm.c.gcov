        -:    0:Source:/home/gerald/github/van/os/os_shm.c
        -:    1:// SPDX-License-Identifier: GPL-2.0
        -:    2:
        -:    3:/*
        -:    4: * Shared memory interfaces.
        -:    5: *
        -:    6: * Copyright (C) 2021 Gerald Schueller <gerald.schueller@web.de>
        -:    7: */
        -:    8:
        -:    9:/*============================================================================
        -:   10:  IMPORTED INCLUDE REFERENCES
        -:   11:  ============================================================================*/
        -:   12:#include "os_shm.h"      /* Shared memory entry points. */
        -:   13:
        -:   14:/*============================================================================
        -:   15:  EXPORTED INCLUDE REFERENCES
        -:   16:  ============================================================================*/
        -:   17:/*============================================================================
        -:   18:  LOCAL NAME CONSTANTS DEFINITIONS
        -:   19:  ============================================================================*/
        -:   20:/*============================================================================
        -:   21:  MACROS
        -:   22:  ============================================================================*/
        -:   23:/*============================================================================
        -:   24:  LOCAL TYPE DEFINITIONS
        -:   25:  ============================================================================*/
        -:   26:/*============================================================================
        -:   27:  LOCAL DATA
        -:   28:  ============================================================================*/
        -:   29:/* Pointer to the OS configuration */
        -:   30:static os_conf_t *os_conf_p;
        -:   31:
        -:   32:/* List of the shared memory devices. */
        -:   33:static os_dev_ops_t *os_dev_ops[OS_DEV_COUNT];
        -:   34:
        -:   35:/*============================================================================
        -:   36:  LOCAL FUNCTION PROTOTYPES
        -:   37:  ============================================================================*/
        -:   38:/*============================================================================
        -:   39:  LOCAL FUNCTIONS
        -:   40:  ============================================================================*/
        -:   41:/**
        -:   42: * os_dev_ops_get() - search for the entry points of the shm device.
        -:   43: *
        -:   44: * @dev_id:  id of the shared memory device.
        -:   45: *
        -:   46: * Return:	the list of the shm device operations.
        -:   47: **/
function os_dev_ops_get called 36 returned 100% blocks executed 90%
       36:   48:static os_dev_ops_t *os_dev_ops_get(int dev_id)
        -:   49:{
        -:   50:	os_dev_ops_t **elem;
        -:   51:	int i;
        -:   52:	
        -:   53:	/* Search for the shared memory devices. */
       54:   54:	for (elem = os_dev_ops, i = OS_DEV_VAN; i < OS_DEV_COUNT;i++, *elem++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        -:   55:		/* Test the device id. */
       54:   56:		if (*elem != NULL && (*elem)->device_id == dev_id)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 67% (fallthrough)
branch  3 taken 33%
       36:   57:			break;
        -:   58:	}
        -:   59:	
        -:   60:	/* Test the device state. */
      36*:   61:	OS_TRAP_IF(i >= OS_DEV_COUNT);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   62:
       36:   63:	return *elem;
        -:   64:}
        -:   65:
        -:   66:/**
        -:   67: * os_dev_ops_add() - extend the list of the shared memory devices.
        -:   68: *
        -:   69: * @op:  list of the shm device entry points.
        -:   70: *
        -:   71: * Return:	None.
        -:   72: **/
function os_dev_ops_add called 4 returned 100% blocks executed 89%
        4:   73:static void os_dev_ops_add(os_dev_ops_t *op)
        -:   74:{
        -:   75:	os_dev_ops_t **elem;
        -:   76:	int i;
        -:   77:
        -:   78:	/* Search for a free device element. */
        6:   79:	for (elem = os_dev_ops, i = OS_DEV_VAN;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        6:   80:	     i < OS_DEV_COUNT && *elem != NULL; i++, *elem++)
branch  0 taken 33%
branch  1 taken 67% (fallthrough)
        -:   81:		;
        -:   82:
        -:   83:	/* End condition. */
       4*:   84:	OS_TRAP_IF(i >= OS_DEV_COUNT);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   85:
        -:   86:	/* Add the new shm element. */
        4:   87:	os_dev_ops[i] = OS_MALLOC(sizeof(os_dev_ops_t));
call    0 returned 100%
        4:   88:	os_memcpy(os_dev_ops[i], sizeof(os_dev_ops_t), op,
call    0 returned 100%
        -:   89:		  sizeof(os_dev_ops_t));
        4:   90:}
        -:   91:
        -:   92:/*============================================================================
        -:   93:  EXPORTED FUNCTIONS
        -:   94:  ============================================================================*/
        -:   95:/**
        -:   96: * os_open() - the van or py process shall call this function to request the
        -:   97: * resources for the shared memory transer.
        -:   98: *
        -:   99: * @device_name:  name of the shared memory deivce: "/van" or "/python".
        -:  100: *
        -:  101: * Return:	the device id.
        -:  102: **/
function os_open called 4 returned 100% blocks executed 85%
        4:  103:int os_open(char *device_name)
        -:  104:{
        -:  105:	os_dev_ops_t **elem;
        -:  106:	int i;
        -:  107:	
        -:  108:	/* Entry condition. */
       4*:  109:	OS_TRAP_IF(device_name == NULL);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  110:	
        -:  111:	/* Search for the shared memory devices. */
        6:  112:	for (elem = os_dev_ops, i = OS_DEV_VAN; i < OS_DEV_COUNT;i++, *elem++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        -:  113:		/* Test the device name. */
       12:  114:		if (*elem != NULL &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 67% (fallthrough)
branch  3 taken 33%
        6:  115:		    os_strcmp((*elem)->device_name, device_name) == 0)
call    0 returned 100%
        4:  116:			break;
        -:  117:	}
        -:  118:
        -:  119:	/* Test the device state. */
       4*:  120:	OS_TRAP_IF(i >= OS_DEV_COUNT);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  121:
        4:  122:	return (*elem)->open(device_name);
call    0 returned 100%
        -:  123:}
        -:  124:
        -:  125:/**
        -:  126: * os_close() - the van or py process shall call this function to remove the
        -:  127: * shared memory ressources.
        -:  128: *
        -:  129: * @dev_id:  van or py device id.
        -:  130: *
        -:  131: * Return:	None.
        -:  132: **/
function os_close called 4 returned 100% blocks executed 100%
        4:  133:void os_close(int dev_id)
        -:  134:{
        -:  135:	os_dev_ops_t *elem;
        -:  136:
        -:  137:	/* Search for the list of the shm device entry points. */
        4:  138:	elem = os_dev_ops_get(dev_id);
call    0 returned 100%
        4:  139:	elem->close(dev_id);
call    0 returned 100%
        4:  140:}
        -:  141:
        -:  142:/**
        -:  143: * os_write() - send the DL payload to py or the UL payload to van and
        -:  144: * suspend the caller until the payload has been processed.
        -:  145: *
        -:  146: * @dev_id:  id of the shared memory device.
        -:  147: * @buf:     pointer to the payload.
        -:  148: * @count:   size of the payload.
        -:  149: *
        -:  150: * Return:	None.
        -:  151: **/
function os_write called 8 returned 100% blocks executed 100%
        8:  152:void os_write(int dev_id, char *buf, int count)
        -:  153:{
        -:  154:	os_dev_ops_t *elem;
        -:  155:
        -:  156:	/* Search for the list of the shm device entry points. */
        8:  157:	elem = os_dev_ops_get(dev_id);
call    0 returned 100%
        8:  158:	elem->write(dev_id, buf, count);
call    0 returned 100%
        8:  159:}
        -:  160:
        -:  161:/**
        -:  162: * os_zread() - py or van waits for incoming payload. With each successiv call, the reference to the
        -:  163: * previous call is released automatically.
        -:  164: *
        -:  165: * @dev_id:  id of the shared memory device.
        -:  166: * @buf:     pointer to the received payload.
        -:  167: * @count:   size of the destination buffer.
        -:  168: *
        -:  169: * Return:	number of the received bytes.
        -:  170: **/
function os_zread called 8 returned 100% blocks executed 100%
        8:  171:int os_zread(int dev_id, char **buf, int count)
        -:  172:{
        -:  173:	os_dev_ops_t *elem;
        -:  174:
        -:  175:	/* Search for the list of the shm device entry points. */
        8:  176:	elem = os_dev_ops_get(dev_id);
call    0 returned 100%
        8:  177:	return elem->zread(dev_id, buf, count);
call    0 returned 100%
        -:  178:}
        -:  179:
        -:  180:/**
        -:  181: * os_read() - py or van waits for incoming payload.
        -:  182: *
        -:  183: * @dev_id:  id of the shared memory device.
        -:  184: * @buf:     pointer to the received payload.
        -:  185: * @count:   size of the destination buffer.
        -:  186: *
        -:  187: * Return:	number of the received bytes.
        -:  188: **/
function os_read called 4 returned 100% blocks executed 100%
        4:  189:int os_read(int dev_id, char *buf, int count)
        -:  190:{
        -:  191:	os_dev_ops_t *elem;
        -:  192:
        -:  193:	/* Search for the list of the shm device entry points. */
        4:  194:	elem = os_dev_ops_get(dev_id);
call    0 returned 100%
        4:  195:	return elem->read(dev_id, buf, count);
call    0 returned 100%
        -:  196:}
        -:  197:
        -:  198:/**
        -:  199: * os_aio_action() - install the read and write callback for the asynchronous
        -:  200: * operations. The reconfiguration of the async. I/O operations is not
        -:  201: * supported. It is recommended to decide themselves for aio immediately after
        -:  202: * os_open before data transfer starts, in order to avoid deadlocks in the sync.
        -:  203: * operations.
        -:  204: *
        -:  205: * @dev_id:  id of the shared memory device.
        -:  206: * @cb:      pointer to the async. I/O callbacks.
        -:  207: *
        -:  208: * Return:	None.
        -:  209: **/
function os_aio_action called 4 returned 100% blocks executed 100%
        4:  210:void os_aio_action(int dev_id, os_aio_cb_t *cb)
        -:  211:{
        -:  212:	os_dev_ops_t *elem;
        -:  213:
        -:  214:	/* Search for the list of the shm device entry points. */
        4:  215:	elem = os_dev_ops_get(dev_id);
call    0 returned 100%
        4:  216:	return elem->aio_action(dev_id, cb);
call    0 returned 100%
        -:  217:}
        -:  218:
        -:  219:/**
        -:  220: * os_aio_write() - this async. I/O operation triggers the van or py irq, to
        -:  221: * start or restart the send actions.
        -:  222: *
        -:  223: * @dev_id:  id of the shared memory device.
        -:  224: *
        -:  225: * Return:	None.
        -:  226: **/
function os_aio_write called 4 returned 100% blocks executed 100%
        4:  227:void os_aio_write(int dev_id)
        -:  228:{
        -:  229:	os_dev_ops_t *elem;
        -:  230:
        -:  231:	/* Search for the list of the shm device entry points. */
        4:  232:	elem = os_dev_ops_get(dev_id);
call    0 returned 100%
        4:  233:	return elem->aio_write(dev_id);
call    0 returned 100%
        -:  234:}
        -:  235:
        -:  236:/**
        -:  237: * os_aio_read() - this async. I/O operation triggers the van or py irq, to
        -:  238: * start or restart the receive actions.
        -:  239: *
        -:  240: * @dev_id:  id of the shared memory device.
        -:  241: *
        -:  242: * Return:	None.
        -:  243: **/
function os_aio_read called 4 returned 100% blocks executed 100%
        4:  244:void os_aio_read(int dev_id)
        -:  245:{
        -:  246:	os_dev_ops_t *elem;
        -:  247:
        -:  248:	/* Search for the list of the shm device entry points. */
        4:  249:	elem = os_dev_ops_get(dev_id);
call    0 returned 100%
        4:  250:	return elem->aio_read(dev_id);
call    0 returned 100%
        -:  251:}
        -:  252:
        -:  253:/**
        -:  254: * os_shm_close() - delete the access and the mapping to the shared memory.
        -:  255: *
        -:  256: * @s:  pointer to the shared memory state.
        -:  257: *
        -:  258: * Return:	None.
        -:  259: **/
function os_shm_close called 4 returned 100% blocks executed 79%
        4:  260:void os_shm_close(os_dev_t *s)
        -:  261:{
        -:  262:	int rv;
        -:  263:	
        -:  264:	/* Remove the reference to the van semaphore. */
        4:  265:	rv = sem_close(s->my_int);
call    0 returned 100%
       4*:  266:	OS_TRAP_IF(rv != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  267:	
        -:  268:	/* Remove the reference to the python semaphore. */
        4:  269:	rv = sem_close(s->other_int);
call    0 returned 100%
       4*:  270:	OS_TRAP_IF(rv != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  271:
        -:  272:	/* Delete the mapping of the shared memory area. */
        4:  273:	rv = munmap(s->start, s->size);
call    0 returned 100%
       4*:  274:	OS_TRAP_IF(rv != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  275:	
        -:  276:	/* Close the shared memory file. */
        4:  277:	rv = close(s->fd);
call    0 returned 100%
       4*:  278:	OS_TRAP_IF(rv < 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  279:
        -:  280:	/* Destroy the mutex for the critical sections in os_queue_add. */
        4:  281:	os_cs_destroy(&s->top.q_mutex);
call    0 returned 100%
        -:  282:	
        -:  283:	/* Delete the mutex for the critical sections in aio_action and in aio_write. */
        4:  284:	os_cs_destroy(&s->aio_mutex);
call    0 returned 100%
        -:  285:	
        -:  286:	/* Delete the mutex for the critical sections in write. */
        4:  287:	os_cs_destroy(&s->write_mutex);
call    0 returned 100%
        -:  288:
        -:  289:	/* Delete the mutex for the critical sections in zread. */
        4:  290:	os_cs_destroy(&s->read_mutex);
call    0 returned 100%
        -:  291:
        -:  292:	/* Destroy the semaphore for os_write(). */
        4:  293:	os_sem_delete(&s->suspend_writer);
call    0 returned 100%
        -:  294:	
        -:  295:	/* Destroy the semaphore for os_zread(). */
        4:  296:	os_sem_delete(&s->suspend_reader);
call    0 returned 100%
        4:  297:}
        -:  298:
        -:  299:/**
        -:  300: * os_shm_open() - map the file into shared memory.
        -:  301: *
        -:  302: * @s:  pointer to the shared memory state.
        -:  303: *
        -:  304: * Return:	None.
        -:  305: **/
function os_shm_open called 4 returned 100% blocks executed 82%
        4:  306:void os_shm_open(os_dev_t *s)
        -:  307:{
        -:  308:	os_shm_top_t *t;
        -:  309:	struct stat statbuf;
        -:  310:	int    rv, prot;
        -:  311:	void  *p;
        -:  312:
        -:  313:	/* Open the shared memory file. */
        4:  314:	s->file_name = OS_SHM_FILE;
        4:  315:	s->fd = open(OS_SHM_FILE, O_RDWR);
call    0 returned 100%
       4*:  316:	OS_TRAP_IF(s->fd < 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  317:
        -:  318:	/* Get information about the shared memory file. */
        4:  319:	rv = fstat(s->fd, &statbuf);
call    0 returned 100%
        4:  320:	s->size = statbuf.st_size;
       4*:  321:	OS_TRAP_IF(rv != 0 || statbuf.st_size != OS_SHM_SIZE);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:  322:
        -:  323:	/* Define the access to the shared memory. */
        4:  324:	prot = PROT_READ | PROT_WRITE;
        -:  325:	
        -:  326:	/* Map the file into shared memory. */
        4:  327:	s->start = mmap(NULL, s->size, prot, MAP_SHARED, s->fd, 0);
call    0 returned 100%
       4*:  328:	OS_TRAP_IF(s->start == MAP_FAILED);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  329:
        -:  330:	/* Create the mutex for the critical sections in write. */
        4:  331:	os_cs_init(&s->write_mutex);
call    0 returned 100%
        -:  332:	
        -:  333:	/* Create the mutex for the critical sections in read. */
        4:  334:	os_cs_init(&s->read_mutex);
call    0 returned 100%
        -:  335:
        -:  336:	/* Create the mutex for the critical sections in aio_action and 
        -:  337:	 * aio_write. */	
        4:  338:	os_cs_init(&s->aio_mutex);
call    0 returned 100%
        -:  339:
        -:  340:	/* Get the reference to the shm topology. */
        4:  341:	t = &s->top;
        -:  342:
        -:  343:	/* Copy the pointer to the start of the shm. */
        4:  344:	p = s->start;
        -:  345:
        -:  346:	/* Map the data transfer queues to the shm. */
        4:  347:	t->dl_queue = (os_shm_queue_t *) p;
        4:  348:	p = p + sizeof(os_shm_queue_t);
        -:  349:	
        4:  350:	t->ul_queue = (os_shm_queue_t *) p;
        4:  351:	p = p + sizeof(os_shm_queue_t);
        -:  352:	
        -:  353:	/* Map the UL buffer to the shm. */
        4:  354:	t->ul_size  = OS_BUF_SIZE;
        4:  355:	t->ul_start = (char *) p;
        4:  356:	t->ul_end   = (char *) p + OS_BUF_SIZE - 1;
        4:  357:	p = (char *) p + OS_BUF_SIZE;
        -:  358:	
        -:  359:	/* Map the DL buffer to the shm. */
        4:  360:	t->dl_size  = OS_BUF_SIZE;
        4:  361:	t->dl_start = (char *) p;
        4:  362:	t->dl_end   = (char *) p + OS_BUF_SIZE - 1;
        -:  363:
        -:  364:	/* Create the mutex for the critical sections in os_queue_add. */
        4:  365:	os_cs_init(&t->q_mutex);
call    0 returned 100%
        -:  366:	
        -:  367:	/* Create the semaphore for os_write(). */
        4:  368:	os_sem_init(&s->suspend_writer, 0);
call    0 returned 100%
        -:  369:	
        -:  370:	/* Create the semaphore for os_zread(). */
        4:  371:	os_sem_init(&s->suspend_reader, 0);
call    0 returned 100%
        4:  372:}
        -:  373:
        -:  374:/**
        -:  375: * os_shm_init() - trigger the installation of the shared memory devices.
        -:  376: *
        -:  377: * @conf:  pointer to the trace configuration.
        -:  378: *
        -:  379: * Return:	None.
        -:  380: **/
function os_shm_init called 2 returned 100% blocks executed 100%
        2:  381:void os_shm_init(os_conf_t *conf)
        -:  382:{
        -:  383:	os_dev_ops_t op;
        -:  384:	
        -:  385:	/* Save the reference to the OS configuration. */
        2:  386:	os_conf_p = conf;
        -:  387:
        -:  388:	/* Trigger the installation of the shared memory devices. */
        2:  389:	os_van_init(conf, &op);
call    0 returned 100%
        2:  390:	os_dev_ops_add(&op);
call    0 returned 100%
        -:  391:	
        2:  392:	os_py_init(conf, &op);
call    0 returned 100%
        2:  393:	os_dev_ops_add(&op);
call    0 returned 100%
        2:  394:}
        -:  395:
        -:  396:/**
        -:  397: * os_shm_exit() - test the state of the shared memory devices.
        -:  398: *
        -:  399: * Return:	None.
        -:  400: **/
function os_shm_exit called 2 returned 100% blocks executed 100%
        2:  401:void os_shm_exit(void)
        -:  402:{
        -:  403:	os_dev_ops_t **elem;
        -:  404:	int i;
        -:  405:
        -:  406:	/* Test the state of the shared memory devices. */
        2:  407:	os_van_exit();
call    0 returned 100%
        2:  408:	os_py_exit();
call    0 returned 100%
        -:  409:
        -:  410:	/* Free the shared memory devices. */
        6:  411:	for (elem = os_dev_ops, i = OS_DEV_VAN; i < OS_DEV_COUNT; i++, *elem++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        4:  412:		if (*elem != NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4:  413:			OS_FREE(*elem);
call    0 returned 100%
        -:  414:	}
        2:  415:}
        -:  416:
        -:  417:/**
        -:  418: * os_shm_trap() - release critical device resources.
        -:  419: *
        -:  420: * @coverage:  if 0, release critical device resoures.
        -:  421: *
        -:  422: * Return:	None.
        -:  423: **/
function os_shm_ripcord called 2 returned 100% blocks executed 100%
        2:  424:void os_shm_ripcord(int coverage)
        -:  425:{
        -:  426:	/* Release critical py device resources. */
        2:  427:	os_py_ripcord(coverage);
call    0 returned 100%
        -:  428:	
        -:  429:	/* Release critical van device resources. */
        2:  430:	os_van_ripcord(coverage);
call    0 returned 100%
        2:  431:}
